<!-- title: 前端开发 - 基础知识 -->
<!-- author: <David Jones qowera@qq.com> -->
<!-- date: 2015-05-15 08:50:16 -->
<!-- category: 前端 -->
<!-- tag: 基础知识 -->

## TCP/IP, HTTP, Socket

网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。IP 协议对应于网络层；TCP 协议对应于传输层；TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输；而 HTTP 协议对应于应用层，主要解决如何包装数据，Socket 则是对 TCP/IP 协议的封装和应用。

### TCP - 传输控制协议

传输控制协议（Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。

TCP 连接包括三个状态：连接创建、数据传送和连接终止。操作系统将 TCP 连接抽象为套接字的编程接口给程序使用，并且要经历一系列的状态改变。

TCP用三路握手（three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。

- 客户端通过向服务器端发送一个 [SYN](http://baike.baidu.com/item/SYN) 来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。
- 服务器端应当为一个合法的 SYN 回送一个 SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
- 最后，客户端再发送一个 [ACK](http://baike.baidu.com/view/204040.htm)。当服务端受到这个 ACK 的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。

### HTTP - 超文本传送协议

HTTP 协议即超文本传送协议(Hypertext Transfer Protocol)，是 Web 联网的基础，HTTP 协议是建立在 TCP 协议之上的一种应用。

HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为"一次连接"。

- 在 HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
- 在 HTTP 1.1 中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

由于 HTTP 在每次请求结束后都会主动释放连接，因此 HTTP 连接是一种 "短连接"，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次 "保持连接" 的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端 "在线"。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

### Socket - 套接字

Socket 是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。

应用层通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP/IP 协议交互提供了 Socket 接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

### 建立 Socket 连接

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket。

套接字之间的连接过程分为三个步骤：
- 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
- 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
- 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

### Socket 连接与 TCP 连接

创建 Socket 连接时，可以指定使用的传输层协议，Socket 可以支持不同的传输层协议 (TCP or UDP)，当使用 TCP 协议进行连接时，该 Socket 连接就是一个 TCP 连接。

### Socket 连接与 HTTP 连接

由于通常情况下 Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是"请求—响应"的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 Socket 连接，服务器就可以直接将数据传送给客户端；若双方建立的是 HTTP 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在"询问"服务器是否有新的数据，如果有就将数据传给客户端。


参考资料

- [传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)

-[TCP/IP SOCKET HTTP及HTTPS之间的关系及各自特性之总结](http://kunyali.blog.51cto.com/4890065/1354922)


<!-- 浏览器篇 START -->

## 浏览器

### 浏览器内核

- Trident: IE
- Gecko: FF
- Servo (FF 与 Samsung 开发中):
- Presto: Opera (< v12.17)
- Webkit: Chrome, Safari, 360极速浏览器, 搜狗浏览器
- Blink (webkit的一个分支): Chrome (>= v28.0.1469.0), Opera

#### 为什么使用 Blink 非 Webkit

在多进程架构上，Google一开始就独自开发了一套沙盒多进程架构，它和后来由Apple主导的WebKit2多进程架构差异很大，为了支持WebKit2架构而加入WebCore的大量代码，对Google不但一点用也没有，还不得不花时间去处理兼容性的问题，而Google需要修改WebCore来支持自己架构的代码又很难进入WebKit主干，必须很小心处理避免影响其它的Port，大量的代码不得不通过迂回的方式放在外部处理，一些没方法在外部处理而需要对WebCore进行大改的特性不得不暂时放弃。
并且，因为历史原因，WebCore本身一开始就没有多线程或者多进程的概念，现有的架构对并行处理的支持非常困难，Google也认为必须对WebCore进行整体架构上的大改才能更好的支持并行处理，更充分利用多核CPU的能力，避免主线程过度拥挤（虽然现在大部分的WebKit Port都把主要的渲染工作分离到其它线程，但是主线程仍然需要负担HTML解析，CSS样式计算和匹配，排版，JS执行等繁重的任务，为了避免单项任务长时间阻塞主线程，WebCore目前是用延时Timer的方式将一个复杂任务分解成多段来顺序执行，这种方式即不优雅，更无法充分利用多核的能力）。
另外，WebCore现在的模块化比较混乱；一些历史遗留的代码和仅仅用于支持某些特定平台的代码导致WebCore代码臃肿不堪；平台相关的处理也没有一个统一的标准和方式，没有一个很好的抽象层去隔离平台相关和平台无关的部分；WebCore为了可以同时支持不同的JS虚拟机（如JSC和V8）导致了额外的性能开销和妨碍了对JS性能更多的改进；除此以外，更安全的隔离机制；对现有的网络层进行更大的结构优化等等这些原因也是Google需要自己发展Blink的主要原因。
总之，Chrome有太多激进的改进需要对WebCore进行大改，而原来那种在外围做文章，曲线救国的方式再也行不通，为了能够自行主导架构的演进方向，避免跟其它Port相互干扰，相互扯皮给双方带来的困扰和痛苦，加快开发的速度，从WebKit主干分离，自己发展新的浏览器引擎就成了必然的选择。

参考文章

- [各主流浏览器内核介绍](http://www.cnblogs.com/vajoy/p/3735553.html)
- [浏览器内核](http://baike.baidu.com/view/1369399.htm)
- [Why Blink and Why not Blink](http://blog.csdn.net/rogeryi/article/details/8759199)


### 浏览器工作原理

#### 浏览器结构

- 用户界面/User Interface - 包括浏览器主窗口、地址栏、前进/后退/停止/刷新等按钮、收藏夹等，其他显示的各个部分也都属于用户界面。
- 浏览器引擎/Browser Engine - 处于用户界面和渲染引擎之间，负责在两者之间传递操作。
- 渲染引擎/Rendering Engine - 负责显示请求的内容，比如HTML，就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
- 网络/Networking - 用于网络调用，比如 HTTP 请求。
- 用户界面后端/UI Backend - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- JavaScript 解释器。用于解析和执行 JavaScript 代码。
- 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

![浏览器的主要组件](http://feit.topming.com/wp-content/uploads/2014/08/Browser-components.png)

#### 渲染引擎主流程

###### 渲染引擎的基本流程

- 渲染引擎首先会通过网络层去获取请求的内容
- 获取到内容后，渲染引擎会进行这样流程：解析 HTML 构建 DOM 树 -> 渲染树的构建 -> 渲染树布局 -> 绘制渲染树 
- 不同的内核渲染流程可能不同

![渲染引擎的基本流程](http://feit.topming.com/wp-content/uploads/2014/08/flow.png)

- 解析HTML构建DOM树 `(DOM Tree)`
  - 解析HTML/SVG/XHTML文档来构建`DOM树 (DOM Tree)`，并将各个标签转化为内容树的DOM节点；
  - 解析外部和内部的CSS并数据来构建`CSS规则树 (CSS Rule Tree)`；
  - 解析Javascript，主要是通过`DOM API`和`CSSOM API`来操作`DOM Tree`和`CSS Rule Tree`；
- 渲染树的构建 `(Rendering Tree)`
  - 浏览器引擎会通过`DOM Tree`和`CSS Rule Tree`来构造`Rendering Tree`；
    - `Rendering Tree`渲染树并不等同于`DOM Tree`，因为一些像Header或display:none的东西就没必要放在渲染树中了；
    - `CSS Rule Tree`主要是为了完成匹配并把CSS Rule附加上`Rendering Tree`上的每个DOM节点。也就是所谓的Frame；
- 渲染树布局 `(Layout)`
  - 就可以根据各个Frame（也就是每个节点）计算分配在屏幕上的准确坐标；
- 绘制渲染树 `(Painting)`
  - 渲染引擎会遍历渲染树，通过用户界面后端API将节点绘制出来。

通常为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，为此在整个 HTML 文档解析完毕之前，就会开始构建渲染树和设置布局，在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。

###### Webkit 流程
![Webkit 流程](http://feit.topming.com/wp-content/uploads/2014/08/wekit-main-flow.png)

###### Mozilla Gecko 流程 
![Gecko 流程](http://feit.topming.com/wp-content/uploads/2014/08/gecko-main-flow.png)


### 重绘 (redraw) 和重排 (reflow)

一个页面载入成功以后形成两个内部数据结构，一个是DOM树（记录页面中的DOM节点结构），一个是渲染树（控制节点如何渲染）。当渲染树构建完毕后，浏览器就可以根据渲染树来绘制页面了，在这个过程中页面就引发了一次页面重排和重绘，这是每个网页在加载时都会执行的。

过多的浏览器重绘和重排，需要付出高昂的性能代价从而大大减低页面的执行效率。

重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、background 等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。

重排（或叫回流 flush）是DOM结构属性发生变化所触发的浏览器行为，例如改变元素的width,height,display 等属性，以及利用JS像页面中追加、删除和修改DOM节点。重排是更明显的一种改变，会导致整个渲染树的重新计算，也必然会有重绘，可见重排必然导致重绘。

###### 以下操作会产生重排/重绘

- 添加或删除可见的DOM 元素（重排&重绘）
- 元素位置改变（重排&重绘）
- 元素尺寸改变（重排&重绘）
- 内容改变，（重排&重绘）
- 浏览器窗口改变尺寸（重排&重绘）
- 字体大小改变（重排&重绘）
- 字体的颜色，Body的颜色改变（重绘）
- 同时当获取以下属性时，因为会造成浏览器强行刷新页面重排队列，而导致页面重排和重绘，这些属性和方法有 `offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`, `scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight`, `clientTop`, `clientLeft`, `clientWidth`, `clientHeight`, `getComputedStyle()` (`currentStyle()` in IE)

###### 减少浏览器的重排和重绘的方法

- 不要经常访问会引起浏览器 flush 队列的属性，需要的时候先缓存处理
- 将需要多次改变的元素的样式属性的，通过一次改变完成
  - 不要把DOM结点的属性值放在一个循环里当成循环里的变量
- 尽可能修改层级比较低的DOM
- 将新建的dom节点操作完毕后在插入到body中
- 把DOM离线后修改
  - 将页面中需要操作的节点先隐藏`display:none`，操作完毕后在显示
- 尽量减少持续改变和动态变化的效果。比如jquery的animate，尽量使用CSS3动画效果来实现
- 为动画的HTML元件使用fixed或absoult的position
- 不要使用 Table 布局
  - 因为可能很小的一个小改动会造成整个table的重新布局

检测工具

- [Google Chrome Timeline](http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/)

参考文章

- [浏览器的工作原理：新式网络浏览器幕后揭秘](http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- [现代浏览器的工作原理](http://feit.topming.com/how-modern-web-browsers-work/)
- [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)
- [页面重构应注意的repaint和reflow](http://www.aliued.cn/2012/11/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98repaints%E4%B8%8E%E9%87%8D%E6%8E%92reflows.html)

<!-- 浏览器篇 END -->


<!-- CSS 篇 START -->

## CSS

### 盒模型

盒模型有两种诠释，一种是 IE 盒模型，而另一种是 W3C 标准盒模型。

```
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃             margin             ┃
┃  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━┓  ┃
┃  ┃          border          ┃  ┃
┃  ┃  ┏━━━━━━━━━━━━━━━━━━━━┓  ┃  ┃
┃  ┃  ┃       padding      ┃  ┃  ┃
┃  ┃  ┃  ┏━━━━━━━━━━━━━━┓  ┃  ┃  ┃
┃  ┃  ┃  ┃              ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃    content   ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃              ┃  ┃  ┃  ┃
┃  ┃  ┃  ┗━━━━━━━━━━━━━━┛  ┃  ┃  ┃
┃  ┃  ┃                    ┃  ┃  ┃
┃  ┃  ┗━━━━━━━━━━━━━━━━━━━━┛  ┃  ┃
┃  ┃                          ┃  ┃
┃  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━┛  ┃
┃                                ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

#### 怪异模式 (Quirks mode) 与 标准模式 (Standards Mode)

IE 浏览器从服务端获取网页后会根据文档的 DOCTYPE 定义显示网页，如果文档正确定义了 DOCTYPE 浏览器则会进入标准模式（Standards Mode），否则浏览器会进入怪异模式或混杂模式（Quirks mode）
在标准模式下，浏览器会根据 W3C 的规范来渲染页面；而在怪异模式中，页面将以 IE5 的渲染方式来渲染页面。

IE盒模型：

- 主要有 IE5, IE6(Q), IE7(Q)
- width = content + padding left/right + border left/right
- box width = width + margin left/right

W3C盒模型：

- 主要由 IE6(S), IE7(S), W3C标准浏览器
- width = content 宽度
- box width = width + padding left/right + border left/right + margin left/right

因为IE盒模型更为合理，[事例](http://blog.csdn.net/ncode/article/details/7428746)，因此在 CSS3 中引入了 `box-sizing`，因此我们可以设置使用IE盒模型的渲染模式，IE8也支持。

```
* {
  box-sizing: border-box;
}
```

##### 设置标准模式

[最详细](http://www.fantxi.com/blog/archives/browser-mode/)

- 加 DOCTYPE 声明
- 设置 X-UA-Compatible 触发。


##### 设置怪异模式

- 无 doctype 声明、定义旧的HTML版本（HTML4以下, 例如3.2）
- 加XML声明，可在ie6下触发
- 在 XML 声明和 XHTML 的 DOCTYPE 之间加入 HTML 注释，可在ie7下触发
- `<!-- keep IE7 in quirks mode -->` 放在 `<!DOCTYPE` 前面

### CSS 选择器

##### 基础的选择器

- `*` 通用元素选择器 `* { margin: 0; padding: 0; }`
- `E` 标签选择器 `p { color: #333; }`
- `.` 类选择器 `.content { color: #333; }`
- `#` ID选择器 `#caption { color: #000; }`

##### 组合选择器

- `E,E` 多元素选择器 `a,p { color: #333; }`
- `E E` 后代元素选择器 `p a { color: #fff; }`
- `E > F` 子元素选择器 `p > a { color: #000; }`
- `E + F` 毗邻元素选择器 `p + p { color: #330; }`

##### 属性选择器

###### CSS 2.1

- `E[attr]` 匹配属性存在 `a[href] { color: #fff; }`
- `E[attr=val]` 匹配属性等于某值 `p[class="error"] { color: red; }`
- `E[attr~=val]` 匹配属性中含有某值，用空格分开 `p[class~="error"] { color: red; }`
- `E[attr|=val]` 匹配连字号分割，若为 `class` 只能匹配到只有一个 `class`且拥有 `-` 的元素 p[lang|=en] { color: green; }`


###### CSS 3

- `E[attr^="val"]` 属性attr的值以val开头的元素 `a[class^="btn-"] { color: red; }`
- `E[attr$="val"]` 属性attr的值以val结尾的元素 `a[class$="-red"] { color: red; }`
- `E[attr*="val"]` 属性attr的值包含val的元素 `a[class*="btn"] { color: red; }`

##### 伪类

###### CSS 2.1

- `E:first-child` 匹配父元素的第一个子元素 `p:first-child { color: #fff; }`
- `E:link` 匹配所未被点击的链接元素 `a:link { color: #fff; }`
- `E:visited` 匹配所有已被点击的链接元素 `a:visited { color: red; }`
- `E:active` 匹配鼠标已按下但未被释放的元素 `a:active { color: red; }`
- `E:hover` 匹配鼠标悬停的元素 `a:hover { color: red; }`
- `E:focus` 匹配获得当前焦点元素 `a:focus { color: red; }`
- [`E:in-range`](http://www.w3schools.com/cssref/sel_in-range.asp) 匹配 `type="number"` 并且在有效范围内的input元素 `input:in-range { color: red; }` IE 不支持
- [`E:out-of-range`](http://www.w3schools.com/cssref/sel_out-of-range.asp) 匹配 `type="number"` 并且不在有效范围内的input元素 `input:out-of-range { color: red; }` IE 不支持
- [`E:valid`](http://www.w3schools.com/cssref/sel_valid.asp) 匹配所有有效的input元素 `input:valid {}`
- [`E:invalid`](http://www.w3schools.com/cssref/sel_invalid.asp) 匹配所有无效的input元素 `input:invalid { color:red; }`
- [`E:optional`](http://www.w3schools.com/cssref/sel_optional.asp) 匹配所有没有 `required` 的input元素 `input:optional { color: red; }` IE 9以上才支持
- [`E:read-only`](http://www.w3schools.com/cssref/sel_read-only.asp) 匹配所有拥有 `readonly` 的input元素 `input:read-only {}`, `input:-moz-read-only {}`
- [`E:read-write`](http://www.w3schools.com/cssref/sel_read-write.asp) 匹配所有不拥有 `readonly` 的input元素 `input:read-write {}`，`input:-moz-read-write {}`
- [`E:lang(c)`](http://www.w3schools.com/cssref/sel_lang.asp) 匹配lang属性等于c的元素 `a:lang(sv) { quotes: “\201D” “\201D” “\2019″ “\2019″; }` 

###### CSS 3

表现性伪类

- `E:enabled` 匹配表单中激活的元素 `input:enabled { color: #000; }`
- `E:disabled` 匹配表单中禁用的元素 `input:disabled { color: #999; }`
- `E:checked` 匹配表单中被选中的单选框与复选框 `input[type="raido"]:checked { background-color: #fff; }`
- `E::selection` 匹配用户当前选中的元素 `p::selection { color: #555; }`

结构性伪类

- `:root` 匹配文档的根元素，对于HTML文档，就是HTML元素，权重大于 `html{}` `:root { color: #fff; }`
- `E:nth-child(n)` 匹配其父元素的第n个子元素，第一个编号为1， `p:nth-child(3) { color: #fff; }`，n由0开始 `p:nth-child(2n) {}`
- `E:nth-last-child(n)` 匹配其父元素的倒数第n个子元素，第一个编号为1 `p:nth-last-child(3) { color: #fff; }`
- `E:nth-of-type(n)` 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 `p:nth-of-type(3) { color: #fff; }`
- `E:nth-last-of-type(n)` 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 `p:nth-last-of-type(n) { color: #fff; }`
- `E:last-child` 匹配父元素的最后一个子元素，等同于:nth-last-child(1) `p:last-child { color: #fff; }`
- `E:first-of-type` 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) `p:first-of-type { color: #fff; }`
- `E:last-of-type` 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) `p:last-of-type { color: #fff; }`
- `E:only-child` 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)
- `E:only-of-type` 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)
- `E:empty` 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 `a:empty { display:block;width:100px;height:100px;background:#ff0; }`
- `E:not` 匹配不符合当前选择器的任何元素 `:not(p) { #fff; }`
- [`E:target`](http://www.w3schools.com/cssref/css3_pr_target.asp) 匹配文档中特定”id”点击后的效果，暂时主流浏览器都均不支持

##### 伪元素

- [`E::first-line`](https://developer.mozilla.org/en-US/docs/Web/CSS/::first-line) 匹配E元素的第一行 `p:first-line { color: red; }` 此时设置 `text-transform: uppercase;` 在 `webkit` 中无效。
- `E::first-letter` 匹配E元素的第一个字母 `p:first-letter { color: red; }`
- `E::before` 在E元素前插入生成的内容 `p:before { content: 'Hello'; }`
- `E::after` 在E元素后插入生成的内容 `p:after { content: 'World'; }`

##### 同级元素选择器

- `E ~ F` 匹配任何在E元素之后的同级F元素 `p ~ ul { color: red; }`

### 优先级与权重

一般我们描述CSS的优先级是这样：

!important > 内联 > id(#) > (class(.) > 同级元素选择器 > 伪类|属性) > 标签|伪元素 > 通配符 > 继承

其实括号内的选择器权重其实均相等，我们先探讨一下如何对比权重值与如何计算出权重的优先级。

#### 权重值的比较

而在普遍的文章描述中，经常会说到 ID 是100，Class 的权重是 10，标签是 1；
其实权重结算的结果并非如此，而是将这些更像如此 ID,Class,E，ID永远比Class优先
当出现这样的情况：

```
html body header nav ul li div p a span em { color: red; }
.num { color: yellow; }
```

此时样式色结果是 yellow，若按Class 权重为10来看，则明显应该是 red；所以我们可以确定此时权重应该是 0,0,11 0,1,0，
当 class 权重一样的时候，会根据次权重的即 E 权重的数值来比较，若都一样会通过后者来确定优先级；

##### 权重值的计算

一条样式规则的整体权重值包含四个独立的部分：[A, B, C, D]

- A表示内联选择器，只有1或者0两个值，若有我们标记A=1，否则A=0，标记的权重为 [1/0,0,0,0]
- B表示ID选择器，表示规则中的ID数量，标记的权重为 [0,N,0,0]
- C表示类选择器、属性选择器等，表示这些选择器的数量，标记的权重为 [0,0,N,0]
- D表示伪元素选择器及标签选择器，表示这些选择器的数量，标记的权重为 [0,0,0,N]

权重值只会看选择器的数量，而不会因为DOM树中两节点的距离而有所不同，例如：`html a == body a`。

##### `!important` 规则例外

当 !important 规则被应用在一个样式声明中时，该样式声明会覆盖CSS中任何其他的声明，无论它处在声明列表中的哪里。尽管如此，!important规则还是与优先级毫无关系。使用 !important 不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。

- Never 永远不要在全站范围的 css 上使用 !important
- Only 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用   !important
- Never 永远不要在你的插件中使用 !important
- Always 要优化考虑使用样式规则的优先级来解决问题而不是 !important

##### `:not` 伪类例外

:not 否定伪类在优先级计算中不会被看作是伪类。事实上，在计算选择器数量时还是会把其中的选择器当做普通选择器进行计数。

##### 关于 `inherit`

除了直接指定到元素上的样式规则以外，每个属性值还有一个可能为 inherit(继承) 的值。表示元素的该样式属性继承自父级元素，与父级元素的定义一致。
继承而来的属性值，权重永远低于明确指定到元素的定义。

参考文章

- [优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)
- [重新认识CSS的权重](http://www.cssforest.org/blog/index.php?id=185)

### BFC 规范

BFC (Block Formatting Context, 块级格式化上下文) 是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。

简单来讲，我们可以把它理解为，我们在进行盒模型布局的时候，如果一个元素符合了成为 BFC 的条件，该元素成为一个隔离了的独立容器，元素内部元素会垂直的沿着其父元素的边框排列，和外部元素互不影响 。比如浮动元素会触发 BFC，浮动元素内部的子元素主要受到该浮动元素的影响，而两个浮动元素之间是互不影响的。

在 CSS3 中，BFC 叫做 Flow Root。在早期的 ie 中也有类似的概念 haslayout IE6、7 的很多布局产生的 bug（如3px 间隙、绝对定位的继承宽度）都可以通过触发 haslayout 修复，比较推荐的方法为 zoom:1 与 height:1%，不会破坏已有的样式，相信大家对它并不陌生。

#### 产生 BFC 的条件

- 根元素或其它包含它的元素
- 浮动 (元素的 float 不为 none)
- 绝对定位元素 (元素的 position 为 absolute 或 fixed)
- 内联块 inline-blocks (元素的 display: inline-block)
- 表格单元格 (元素的 display: table-cell，HTML表格单元格默认属性)
- 表格标题 (元素的 display: table-caption, HTML表格标题默认属性)
- overflow 的值不为 visible 的元素
- 弹性盒 flex boxes (元素的 display: flex 或 inline-flex)

#### BFC 对于布局的影响

根据 w3c 的规范，在一个 BFC 中，盒子(boxes) 从 BFC 的顶端往下，一个挨着一个垂直放置。相邻盒子之间的垂直距离取决于它们的 margin 属性，同一个 BFC 中，相邻块级盒子之间的垂直 margin 值会折叠。这句话包含几个限定条件，边距折叠的分析在以后的文章中再展开，这次仅注意到边距折叠只发生在同一个 BFC 中。

#### BFC 对浮动的影响

根据 w3c 的规范，在 BFC 中，每个盒子的左外边缘(edge)都会触及 BFC 的左边缘，甚至浮动元素存在的时候也是这样(尽管盒子的行盒 line boxes 会因为浮动元素而被压缩)，除非盒子创建了一个新的 BFC。

#### 合并外边距与BFC

相邻的两个盒子合并外边距折叠的结果：

- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 
- 两个外边距一正一负时，折叠结果是两者的相加的和。

产生折叠的必备条件：margin必须是邻接的，而根据w3c规范，两个margin是邻接的必须满足以下条件：

- 必须是处于常规文档流(非float和绝对定位)的块级盒子,并且处于同一个BFC当中
- 没有线盒，没有空隙(clearance)，没有padding和border将他们分隔开
- 都属于垂直方向上相邻的外边距，可以是下面任意一种情况
- 元素的 margin-top 与其第一个常规文档流的子元素的 margin-top
- 元素的 margin-bottom 与其下一个常规文档流的兄弟元素的 margin-top
- height 为 auto 的元素的m argin-bottom 与其最后一个常规文档流的子元素的 margin-bottom
- 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的 BFC 的元素的 margin-top 和 margin-bottom


建议阅读参考文章结合例子理解
- [深入理解BFC和Margin Collapse](http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)
- [BFC、浮动、清除和hasLayout](http://blog.comiclee.com/2015/02/bfc%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4%E5%92%8Chaslayout)
- [【深入BFC】 关于CSS中float布局，清除浮动，和margin合并的原理解析，解开你心中的那些困惑！](http://www.cnblogs.com/v10258/p/3530290.html)


### haslayout



<!-- CSS 篇 END -->


<!-- Javascript 篇 START -->

## Javascript

### 作用域

作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。
若出现同名变量，作用域中的变量会比全局变量的优先级高。而且改变作用域下的变量，全局变量不会受到任何影响。
Javascript 并没有块状作用域，因此在相同作用域下不同的块状中定义变量，他们均是该作用域变量，作用域下都能引用。

#### Scope Chain - 作用域链

作用域链就是包含了函數被創建的作用域中對象的集合。它決定了哪些數據能被函數訪問。
这个原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。

#### Hoisting - 声明提升

当定义一个变量时，定义的声明会在程序运行时优先执行定义(非赋值)

```
console.log(a)    // undefined，并不会
var a = 1         // 声明被提升，这里只执行赋值
console.log(a)    // 1
```

#### Window Scope

基于浏览器的 Javascript 定义一个全局变量可以通过给 Window 对象添加属性。
同时，没有经过 `var` 定义的变量均被定义为全局变量 (此情况是没有标志 `use strict` 的情况下)
当函数内部调用一个从未被定义的值，它会指向 Window，若通过 'use strict' 标志了该作用域，则会报错

#### 静态作用域 与 动态作用域

静态作用域 (Static/Lexical Scope) 又叫做词法作用域，采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见（visibility）；在这段区域以外该变量不可见（或无法访问）。词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。

动态作用域 (Dynamic Scope) 的变量叫做动态变量。只要程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。动态作用域里，取变量的值时，会由内向外逐层检查函数的调用链，并打印第一次遇到的那个绑定的值。

下面闭包章节将有具体例子详细说明

参考文章

- [作用域](https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F#.E9.9D.99.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F.E4.B8.8E.E5.8A.A8.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F)


### Closure - 闭包

首先我们了解一下函数编程的一些基本定义，函数式语言中，函数即是数据，则我们可以把函数作为参数传递，也可以返回一个函数，然而在 ECMAScript 中也一样。
这些接受函数式参数的函数称为高阶函数 (HOF - high-order function)；
而带函数返回值的函数称为带函数值的函数 (functions with functional value)；
把自己作为参数的函数称为自应用函数 (self-applicative function)；
把自己作为返回值的函数称为自复制函数 (self-replicative function)

```
# 高阶函数
function q(funcVar) {
  funcVar()
}

# 带函数值的函数
function q() {
  return function() {}
}

# 自应用函数
(function() {
  
})()

# 自复制函数
function q() {
  return q
}
```

#### Funarg Problem - 泛函参数问题
Funarg Problem 的一个子问题是 upward funarg problem (自下而上)，当一个函数作为另一个函数的返回值时，并且使用了自由变量[free variable]的时候会发生。即便它的父级上下文环境已经结束了，它可以引用父级的变量。这个内部函数在创建时就会将父级的作用域链保存在自己的作用域[[Scope]]中。当函数运行时，上下文环境的作用域量是由活跃变量[activation object]和它[[Scope]]属性组合而成。

```
Scope chain = Activation object + [[Scope]]
```

请再次注意这个很重要的点 – 在函数创建期间[creation moment]，函数会将父级的作用域链保存起来，因为随后调用这个函数的时候使用的已经保存的作用域链来搜寻变量。

```
function foo() {
  var x = 10
  return function() {
    console.log(x)
  }
}

var x = 20
foo()()  // 10, but not 20
```

这种形式的作用域称为静态作用域。理论上来说，也会有动态作用域[dynamic scope], 也就是上述的x被解释为20，而不是10. 但是EMCAScript不使用动态作用域。

“funarg problem”的另一个类型就是自上而下[”downward funarg problem”].在这种情况下，父级的上下会存在，但是在判断一个变量值的时候会有多义性。也就是，这个变量究竟应该使用哪个作用域。是在函数创建时的作用域呢，还是在执行时的作用域呢？为了避免这种多义性，可以采用闭包，也就是使用静态作用域。

```
var x = 10

function foo() {
  console.log(x)
}

(function(funarg) {
  var x = 20
  
  // there is no ambiguity,
  // because we use global "x",
  // which was statically saved in
  // [[Scope]] of the "foo" function,
  // but not the "x" of the caller's scope,
  // which activates the "funArg"

  funarg() // 10, but not 20
})(foo)
```

从上述的情况，我们似乎可以断定，在语言中，使用静态作用域是闭包的一个强制性要求。不过，在某些语言中，会提供动态和静态作用域的结合，可以允许开发员选择哪一种作用域。但是在ECMAScript中，只采用了静态作用域。所以ECMAScript完全支持使用[[Scope]]的属性。我们可以给闭包得出如下定义

```
A closure is a combination of a code block (in ECMAScript this is a function) and statically/lexically saved all parent scopes.Thus, via these saved scopes a function may easily refer free variables.
```

闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。

几个函数可能含有相同的父级作用域（这是一个很普遍的情况，例如有好几个内部或者全局的函数）。在这种情况下，在[[Scope]]中存在的变量是会共享的。一个闭包中变量的变化，也会影响另一个闭包的。

#### 闭包的定义

闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数，也可以说闭包是由函数和与其相关的引用环境组合而成的实体。


参考文章

- [深入理解JavaScript系列（16）：闭包（Closures）](http://www.cnblogs.com/tomxu/archive/2012/01/31/2330252.html)
- [执行上下文其三：闭包 Closures](http://www.nowamagic.net/librarys/veda/detail/1646)


### 原型与继承

#### 原型模型

JavaScript 不包含传统的类继承模型，而是使用 prototypal 原型模型。在基于类的面向对象方式中，对象（object）依靠类（class）来产生。而在基于原型的面向对象方式中，对象（object）则是依靠构造器（constructor）利用 原型（prototype）构造出来的。在 JavaScript 中，"一切都是对象，函数是第一类"，`Function` 和 `Object` 都是函数的实例。

#### 生成对象方式

```
var obj = {
  name: 'david'
}

var Foo = function(name) {
  this.name = name
}

Foo.prototype.do = function() {}
var personA = new Foo('David')

# ECMAScript 5 引入, 相当于
Object.create = function(parent) {
  function Foo() {}
  Foo.prototype = parent;
  return new Foo();
}

var personB = Object.create({
  gender: 'male'
})

console.log(personB.gender) // male
```

#### prototype chain - 原型链

JavaScrip 可以采用构造器(constructor) 生成一个新的对象，每个构造器都拥有一个 prototype 属性，而每个通过此构造器生成的对象都有一个指向该构造器原型 (prototype) 的内部私有的链接 (proto)，而这个 prototype 因为是个对象，它也拥有自己的原型，这么一级一级指导原型为null，这就构成了原型链。

在 Javascript 中有一个隐藏的属性 `__proto__` (proto 是一个不应在你代码中出现的非正规的用法，这里仅仅用它来解释JavaScript原型继承的工作原理。)

```
var Foo = function() {}
Foo.prototype.say = 'hello'

var a = new Foo()
console.log(a.__proto__ === Foo.prototype) // true
console.log(a.__proto__.construct === Foo) // true
console.log(a.__proto__) // Foo { say: 'hello' } --> Foo.prototype
console.log(a.__proto__.__proto__) // Object {} --> Object.prototype
console.log(a.__proto__.__proto__) // null --> Object.__proto__
```

更复杂一点的原型链继承结构

```
function Animal(name) {
  this.name = name
}

Animal.prototype = {
  eat: function() {
    console.log('something to eat..')
  }
}

function Mammal() {
  this.name = 'mammal'
}

Mammal.prototype = new Animal('animal')
Mammal.prototype.constructor = Mammal

function Horse() {
  this.name = 'horse'
}

Horse.prototype = new Mammal()
Horse.prototype.constructor = Horse

Horse.prototype.eat = function() { 
  console.log('eat glass')
}

var horseA = new Horse()
console.log(horseA.__proto__ === Horse.prototype) // true
console.log(Horse.prototype.__proto__ === Mammal.prototype) // true
console.log(Mammal.prototype.__proto__ === Animal.prototype) // true
```

在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的隐式引用（implicit reference），这个引用称之为原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的原型链（prototype chain）

当前的原型继承（如 Object.create 以及 proto）还是存在以下缺点

- 标准性差：proto 不是一个标准用法，甚至是一个不赞成使用的用法。同时原生态的 Object.create 和道爷写的原版也不尽相同。
- 优化性差： 不论是原生的还是自定义的 Object.create ，其性能都远没有 new 的优化程度高，前者要比后者慢高达10倍。


##### 属性查找

当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined

##### hasOwnProperty

hasOwnProperty是Object.prototype的一个方法，它可是个好东西，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。

```
Object.prototype.bar = 1

var foo = {
  goo: undefined
}

cnosole.log(foo.bar) // 1
'bar' in foo // true

foo.hasOwnProperty('bar') // false
foo.hasOwnProperty('goo') // true
```


参考文章

- [深入理解javascript原型继承](http://www.jianshu.com/p/d2742610ec30)
- [深入理解JavaScript系列（5）：强大的原型和原型链](http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html)

### Ajax 

Ajax 的全称是 Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统 web 开发中采用的同步的方式。

#### 理解同步异步

异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。

#### Ajax 原理

Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据。也就是 Javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。

首先了解一下 XMLHttpRequest 对象的属性

- onreadystatechange - 每次状态改变所触发事件的事件处理程序
- responseText - 从服务器进程返回数据的字符串形式
- responseXML - 从服务器进程返回的DOM兼容的文档数据对象
- status - 从服务器返回的数字代码，比如常见的 404(未找到) 和 200(已就绪)
- statusText - 伴随状态码的字符串信息
- readyState - 对象状态值
  - 0 (未初始化) 对象已建立，但是尚未初始化(尚未调用open方法)
  - 1 (初始化) 对象已建立，尚未调用 send 方法
  - 2 (发送数据) send 方法已调用，但是当前的状态及 http 头未知
  - 3 (数据传送中) 已接收部分数据，因为响应及 http 头不全，这时通过 responseBody 和 responseText 获取部分数据会出现错误
  - 4 (完成) 数据接收完毕，此时可以通过通过 responseXml 和 responseText 获取完整的回应数据

```
var xmlhttp
if (window.XmlHttpRequest) {
  xmlhttp = new XmlHttpRequest()
}

// IE 浏览器创建 XmlHttpRequest 对象
if (window.ActiveXObject) {
  try {
    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")
  }
  catch(e) {
    try {
      xmlhttp = new ActiveXObject("msxml2.XMLHTTP")
    }
    catch (err) {}
  }
}

xmlhttp.open('POST', url, false)
xmlhttp.onreadystatechange = function() {
  if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
    console.log(xmlhttp.responseText)
  }
}

xmlhttp.send(null)
```

参考文章:

- [深入理解Ajax原理](http://blog.csdn.net/lfsf802/article/details/7233640)
- [逐渐深入地理解Ajax](http://www.cnblogs.com/tugenhua0707/p/4524877.html)
- [Ajax工作原理](http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html)

### Cross Domain - 跨域

#### jsonp

jsonp 原理就是利用 javascript 脚本引用可以跨域。首先客户端会注册一个 callback，然后把 callback 传递给服务器。服务器生成 JSON 数据并且通过 javascript 语法方式生成一个 function, function 的名字就是 jsonp 传递上来的名字。最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。客户端浏览器，解析 script 标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）

```
var sc = document.createElement(script)
sc.src = 'http://example2.com/getinfo.php?callback=jsonpcallback'
document.getElementsByTagName('head')[0].appendChild(sc)
```

#### 设置 document.domain

浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过 ajax 的方法去请求不同源中的文档。它的第二个限制是浏览器中不同域的框架之间是不能进行 js 的交互操作的。但是我们却可以在相同的主域下将不同的子域设置成一样的 domain。

```
# a.example.com
document.domain = 'example.com'

# b.b.example.com
document.doamin = 'example.com'
```

这样就可以操作子页面的 Javascript 脚本了，这些我们都可以通过创建 iframe 来实现。最后通过调用这个 iframe 的 AJAX 请求相应的数据并返回给主页面达到跨域的效果。

#### 通过 window.name

window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。

因此当我们通过跳转页面而达到传输数据的效果

```
# a.html
window.name = 'something...'
setTimeout(function() {
  location.href = 'b.html'
})

# b.html
console.log(window.name) // something...
```

注意，window.name 的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器；第二，若两页处于不同的域中，该方式也使用。

#### HTML5 window.postMessage

`window.postMessage(message, targetOrigin)` 方法是html5新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源，目前 IE8+, FireFox, Chrome, Opera 等浏览器都已经支持 `window.postMessage` 方法。

调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符"*"。

需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。

```
# a.html
window.postMessage('message...', '*')

# b.html
window.onmessage = function(evt) {
  evt = evt || event
  console.log(evt.message) // message...
}
```

#### FLASH 跨域请求

使用 flash 插件 设置 crossdoamin.xml，该文件放在根目录下。

```
<!-- crossdoamin.xml -->
<?xml version="1.0"?>
<cross-domain-policy>
<allow-access-from domain="*.example.com" />
</cross-domain-policy>
```

#### 服务器代理

设置一个同域的域名，该页面会发出跨域请求，并返回信息。这样就可以通过服务器作为中转进行跨域请求了。

<!-- Javascript 篇 END -->


<!-- HTML 篇 START -->

## HTML

### 标记语言 SGML, HTML, XML, XHTML

SGML (Standard Generalized Markup Language，标准通用标记语言) 是现时常用的超文本格式的最高层次标准，是可以定义标记语言的元语言，甚至可以定义不必采用< >的常规方式。HTML 是被用 SGML 描述的标记语言
HTML (HyperText Markup Language，超文本标记语言)，是为 "网页创建和其它可在网页浏览器中看到的信息" 设计的一种标记语言，适合 Web，可是标记较少，不支持其他领域的标记语言
XML (eXtensible Markup Language，可扩展标记语言)，根据网上的理解，使用来在网络传输中表示数据的结构的，及我们可以通过 XML，可以得到数据的真实结构，与 HTML 对比理解，HTML 主要用于在网络上控制数据信息的布局，XML 则用于记录数据本身的结构，包括保存数据。前者侧重与表现，后者侧重于记录
XHTML (eXtensible HyperText Markup Language，可扩展超文本标记语言)，从继承关系上讲，HTML是一种基于标准通用标记语言（SGML）的应用，是一种非常灵活的置标语言，而XHTML则基于可扩展标记语言（XML），XML是SGML的一个子集

```
 ┏━━━━┓
 ┃SGML╋━━━┓
 ┗━╋━━┛   ┃ 
   ┃      ┃
 ┏━╋━┓  ┏━╋━━┓
 ┃XML┃  ┃HTML┃
 ┗━╋━┛  ┗━━━━┛
   ┃
   ┃
┏━━╋━━┓
┃XHTML┃
┗━━━━━┛
```

因此利用 SGML 创建了 HTML 参照和必须共同遵守的 DTD (document type definition，文本类型定义)，你会经常在 HTML 页面的头部发现 `DOCTYPE` 属性，用来定义用于解析目标 DTD

```
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

### SVG
SVG（Scalable Vector Graphics 可缩放矢量图形）表示可缩放矢量图形。他是基于文本的图形语言，使用文本，线条，点等来进行图像绘制


<!-- HTML5 篇章 START -->

## HTML5

HTML5 是最新的 HTML 标准，他的主要目标是提供所有内容而不需要任何的像 flash，silverlight 等的额外插件，这些内容来自动画，视频，富 GUI 等；HTML5 是万维网联盟（W3C）和网络超文本应用技术工作组（WHATWG）之间合作输出的。

### HTML5 与 HTML4 的区别

#### 文档范围

HTML5 没有使用 SGML 或者 XHTML，他是一个全新的东西，因此你不需要参考 DTD，对于 HTML5，你仅需放置下面的文档类型代码告诉浏览器识别这是 HTML5 文档，若不指明 `<!DOCTYPE html>` (不区分大小写)，则浏览器不会认为该文档为 HTML 文档，会导致 HTML5 的标签不能正常工作。 

#### 向后兼容

HTML5 定义了 HTML5 语法，日前已广泛兼容于网络上 HTML4 和 XHTML1 的文档，但不兼容大部分 HTML4 中的深奥 SGML 特性，大部分 UA 都不支持它们，比如处理指令(processing instructions) 和 标签简写(shorthand markup)。

##### 语法

HTML5 语法中同时定义了解析规则——包括异常的处理方式。这种解析规则能够广泛支持 HTML4 领域的实现，UA 可以使用这些规则来解析媒体类型为 text/html 的资源。

下面是一个能够说明HTML语法的示例文档：

```
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Example document</title>
  </head>
  <body>
    <p>Example paragraph</p>
  </body>
</html>
```

另外一个可以被用于 HTML 的语法是 XML。 XML 语法可兼容于 XHTML 文档或实现。使用XML语法的文档需要配套XML文档的媒体类型如 application/xhtml+xml 或 application/xml 来使用，同时，元素需要遵循XML规则，被放到 http://www.w3.org/1999/xhtml 命名空间中：

```
<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Example document</title>
  </head>
  <body>
    <p>Example paragraph</p>
  </body>
</html>
```

##### 符号编码

HTML标准中要求开发声明编码方式，有这些方式可以做到：

- 传输层，可以用 HTTP 头部的 Content-Type
- 在文档头部放置对应使用的编码的 BOM
- 使用有 charset 的 meta 元素 `<meta charset="UTF-8">` 代替 `<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">` (仍可继续使用)

XML语法中，开发需要按照XML标准来设置编码。

##### MathML 和 SVG

HTML语法允许文档内嵌MathML和SVG元素。

- math 和 svg 的开始标签将会导致HTML解析器转为特殊的插入模式，以将元素和属性放入合适的命名空间，并转化大小写，并支持XML中的空元素语法
- HTML中 的 math/svg 的相关元素及其属性依然是区分大小写的
- 可以省略namespace（svg 的 namespace 可以省略 xmlns="http://www.w3.org/2000/svg"）
- 在这个特殊的插入模式里，可以使用CDATA语法
- 一些 MathML 和 SVG 元素可能导致解析器转回 HTML 解析模式，比如 mtext 和 foreignObject，在这些元素内部你可以使用HTML元素或者新的 math/svg 元素。

```
<!doctype html>
<title>SVG in text/html</title>
<p>
 A green circle:
 <svg><circle r="50" cx="50" cy="50" fill="green"/></svg>
</p>
```

### HTML5 新增标签元素

#### 结构元素

- header - 页面头部
- nav - 主导航
- section - 独立章节
- article - 独立文章
- footer - 页面底部

#### 块级元素

- aside - 用于表示侧栏、贴士、摘要等
- figure - 用来包裹图片，并配合 `figcaption` 标签给图片一个说明
- [dialog](http://www.w3school.com.cn/tags/index.asp) - 用来表示人与人之间的交流互动，默认设置了绝对定位居中

#### 行内元素

- mark - 定义有记号的文本
- [time](http://www.w3school.com.cn/tags/tag_time.asp) - 时间格式，会在标签内给它一个datetime的属性，属性值为电脑可识别的时间格式 - `<time datetime="2008-02-14">情人节</time>`
- [meter](http://www.w3school.com.cn/tags/tag_meter.asp) - 标签定义度量衡，它拥有6个属性value, min, max, low, high, optimum，分别表示当前、最小、最大、低区、高区、最佳
- [progress](http://www.w3school.com.cn/tags/tag_progress.asp) - 用来表示进度条，value, max, 按照 value/max 来确定进度, IE9或以下不支持

#### 多媒体元素
- canvas - 定义图形
- [video](http://www.w3school.com.cn/tags/tag_video.asp) - HTML5 视频标签 - `<video src="movie.ogg" controls="controls"></video>`
- [audio](http://www.w3school.com.cn/tags/tag_audio.asp) - HTML 5 音频标签 - `<audio src="a.wav"></audio>`
- [source](http://www.w3school.com.cn/tags/tag_source.asp) - 定义媒介源，当媒体有多个的时候，浏览器会自动选择自身支持的那个媒介源
- [track](http://www.w3school.com.cn/tags/tag_track.asp) - 定义用在媒体播放器中的文本轨道，IE9,FF,Safari 不支持
- [embed](http://www.w3school.com.cn/tags/tag_embed.asp) - 定义嵌入的内容 - `<embed src="a.swf"/>`
- [details](http://www.w3school.com.cn/tags/tag_details.asp) - 用于描述文档或某个部分的细节，配合 `summary` 使用

#### 表单元素

- datalist - 定义下拉列表
- [keygen](http://www.w3school.com.cn/tags/tag_keygen.asp) - 标签规定用于表单的密钥对生成器字段，IE不支持
- [output](http://www.w3school.com.cn/tags/tag_output.asp) - 执行计算显示结果，IE 不支持
- datagrid - 可选数据的树形列表

#### 其他元素

- wbr - 定义一段 work brak 文本，不受任何样式影响
- menu - 菜单列表 (暂无支持)
- command - 行为按钮 (暂无支持)

#### 补充

- [datalist 不受任何样式影响](http://stackoverflow.com/questions/13693482/is-there-a-way-to-apply-a-css-style-on-html5-datalist-options)

#### HTML5 废弃的元素

下面的元素被废弃的原因是用CSS处理可以更好地替代他们：

- basefont
- big
- center
- font
- strike
- tt

下面的元素被废弃的原因是他们的使用破坏了可使用性和可访问性：

- frame
- frameset
- noframes

下面的元素被废弃的原因是不经常使用他们，也会引起混乱，而且其它元素也可以很好地实现他们的功能：

- acronym - 被废弃是因为它经常使页面错乱，可以使用abbr代替
- applet - 被废弃是因为可以使用object代替
- isindex - 被废弃是因为使用表单控件代替
- dir - 被废弃是因为使用ul代替

最后，noscript元素只能在HTML里使用，而不能在XML里使用。

#### 废弃的属性

HTML5的规范里有对这些属性的代替方案，[点击访问](http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#non-conforming-features)。

- link, a - rev, charset
- a - shape, coords
- img, iframe - longdesc
- link - target
- area - nohref
- head - profile
- html - version
- img - name
- meta - scheme
- object - archive, classid, codebase, codetype, declare, standby
- param - valuetype, type
- td, th - axis, abbr
- td - scope
- table - summary

另外， 在HTML5里，以下元素的视觉属性也将被废弃，因为这些功能可用CSS来实现：

- caption, iframe, img, input, object, legend, table, hr, div, h1, h2, h3, h4, h5, h6, p, col, colgroup, tbody, td, tfoot, th, thead, tr - align
- body - alink, link, text, vlink
- body - background
- table, tr, td, th, body - bgcolor
- object - border
- table - cellpadding, cellspacing
- col, colgroup, tbody, td, tfoot, th, thead, tr - char, charoff
- br - clear
- dl, menu, ol, ul - compact
- table - frame
- iframe - frameborder
- td, th - height
- img, object - hspace, vspace
- iframe - marginheight, marginwidth
- hr - noshade
- td, th - nowrap
- table - rules
- iframe - scrolling
- hr - size
- li, ol, ul - type
- col, colgroup, tbody, td, tfoot, th, thead, tr - valign
- hr, table, td, th, col, colgroup, pre - width

[废弃的元素（Element）](http://www.cnblogs.com/TomXu/archive/2011/12/17/2269168.html)

#### HTML5 新增 API

- 媒体标签 video 和 audio 的播放流程控制、同步多个媒体标签、字幕等接口
- 表单限制验证接口 - `setCustomValidity()`
- 引入应用缓存机制，允许 Web App 离线的 API
- 允许 Web App 注册为对应协议或媒体类型的处理应用的 APP 的 API - `registerProtocolHandler()`, `registerContentHandler()`
- 引入 contenteditable 属性，允许编辑任意元素的接口
- 暴露会话历史、允许使用脚本无刷新更新页面 URL - `History`
- base64 转换 API - `atob()`, `btoa()`
- 处理搜索服务提供方的接口 - `AddSearchProvider()`, `IsSearchProviderInstalled()`
- 打印文档的接口 - `print()`
- External 接口

### Web Worker

当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能
但是 Web worker 线程不能修改 HTML 元素，全局变量和 Window.Location 一类的窗口属性。你可以自由使用 Javascript 数据类型，XMLHttpRequest 调用等

主页面，我们可以通过 `postMessage(sData)` 给内部发送消息，通过 `onmessage` `onerror` 等事件来捕获Worker内部返回的信息
Worker 没有加载好脚本之前，所有的 `postMessage()` 都会在 Worker 加载并执行完毕后被触发回调
当我们想停掉 Worker 时，我们可以使用 `terminate()`

Worker 线程，我们也是通过 `postMessage()` 来给外部发送消息
若想关闭 Worker 行为，我们则使用 `close()` 方法
`importScripts()` Worker 线程动态加载外部脚本，该方法会冻结 Worker 线程，直到动态加载脚本加载完毕或执行完毕(浏览器差异)
  - `importScripts()` 支持同时加载多个脚本
  - 同时加载多个脚本在各个浏览器中均为并行加载 (前提是HTTP连接数够用)
  - 但执行顺序是严格按照参数顺序进行的，无论哪个先加载完 (FF有差异) 

#### Web Worker 在各浏览器中的差异

##### 异常
Opera 中，一旦发生一个语法错误或运行时错误，有时候会多抛出一个 Internal error 并且 lineno 总是 0
Opera 中，一般的语法错误或执行期异常(如调用未定义变量，throw new Error(s)除外) 总是无法给出准确的错误信息且 lineno 总是 
Chrome、Safari中， `onerror` 并不捕获加载失败的404异常

##### 关于worker引入文件的缓存问题
Opera中，一但脚本被缓存起来那么即使右键-重新载入，也会直接去读 cache

##### 调用 `close()` 方法后的差异

Opera中，一但在 Worker 线程中调用 `close()` 方法，那么就代表着一切都结束了。如果在 `close()` 后你仍然试图使用 Worker 中的某些属性、事件、或方法则会抛出一个 Internal error，但其他浏览器则不会
Opera中，调用 `close()` 后，出现的 `postMessage()` 给主页面传递信息，不会再触发主页面的 `onmessage` 回调，其他浏览器则可以
FF中，调用 `close()` 后 Worker 虽然不再响应页面的 `postMessage()`，但是在 `close()` 调用之前，页面 `postMessage()` 给 Worker 线程的信息仍然会在 Worker 线程结束后被触发回调，其他浏览器则不会
chrome中，调用close()后 self 对象被赋值为 null 但你仍然可以和其他浏览器一样直接调用 WorkerGlobalScope 对象的方法。所以，应避免使用 self.postMessage，self.onmessage = function(){}，self.close() 而采用直接调用的方式 (如 onmessage=function(){}; )

##### 关于 `terminate()`

Opera 中，主页面调用 `terminate()` 后再调用 `postMessage()` 会抛出异常，其他浏览器则不会。
Opera 中，`terminate()` 执行之后，Worker 线程向外部传递数据或抛出异常均会被捕获，其他浏览器均不会。

##### 关于 `importScripts()`

FF中，`importScripts()` 加载脚本时，虽然同样会冻结当前 Worker 线程，但执行期是在 Worker 线程结束后，而其他浏览器的加载、执行都会冻结 Worker 线程。
FF中，`importScripts()` 方法加载多个脚本时，执行顺序是不确定的，遵循先到先执行原则
FF、Safari、Chrome 中，`importScripts()`加载脚本失败时，会抛出异常且可被主页面的 `onerror` 捕获，Opera 则不会
FF 中，`importScripts()` 加载多个脚本时，虽然都是并行加载，但执行却要等待文件都加载完毕后才开始执行，期间任何一个文件加载失败都将导致直接退出当前执行环境并且 Worker 线程代码也不回执行，其他浏览器则不会
Safari、Chrome，使用 `importScripts()` 加载多个脚本时，任何一个脚本加载失败，都将导致退出当前执行环境，但先加载好的外部脚本可以正常执行
Opera 会无视加载失败错误，继续执行后面的代码

##### 关于 Worker 内创建 Worker 的差异

Safari、chrome 不允许 Worker 内部再次创建一个 Worker，即 Safari、Chrome 中的 WorkerGlobal 并没有 Worker 成员
FF、opera 允许 Worker 内部再次创建一个 Worker

参考资料

- [HTML5 Web Worker](http://www.cnblogs.com/_franky/archive/2010/11/23/1885773.html)


### Server-Sent Events (SSE) -  单向消息传递

Server-Sent 事件指的是网页自动获取来自服务器的更新。以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。

参考资料

- [HTML 5 服务器发送事件](http://www.w3school.com.cn/html5/html_5_serversentevents.asp)


### Websocket

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行[全双工](https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5)通讯的协议，使服务端和客户端可以相互推送数据。在 WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。这里需要注意一点，这和 TCP 的三次握手又是不一样的。TCP 的三次握手是为了保证连接可靠，当 TCP 三次握手成功的时候，websocket 的握手阶段才真正开始。TCP 三次握手传送的是 TCP 报文，而websocket的握手传送的是 HTTP 报文，这个是不太一样的地方。

握手开始的时候，我们需要现发送一个HTTP 1.1的请求头部：

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

服务端返回的成功握手请求头部如下

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

一旦连接成功后，就可以在全双工的模式下在客户端和服务端之间来回传送WebSocket消息。这就意味着，在同一时间、任何方向，都可以双向发送基于文本的消息。每个消息已0×00字节开头，以0xff结尾（这样就可以解决TCP协议中的黏包问题，在TCP协议中，会存在两个缓冲区来存放发送的数据或者接收的数据，如果没有明显的分隔符，服务端无法正确识别命令），中间数据的编码是 UTF-8。

#### websocket 的使用

```
var ws
if ('WebSocket' in window) {
  ws = new WebSocket('ws://example.com:9998/websocket')
  
  // 成功建立连接触发事件
  ws.onopen = function() {
    ws.send('something to send...')
  }
  
  // 收到信息触发事件
  ws.onmessage = function(evt) {
    var msg = evt.data
    console.log('i received a message: ' + msg)
  }
  
  // 连接关闭触发事件
  ws.onclose = function() {
    console.log('Connecting is closed...')
  }
}
else {
  console.log('Your browser is not supported WebSocket. ⊙﹏⊙b')
}
```

#### 使用 websocket 主要考虑因素

- 请求数：WebSocket可以一直保持连接，通过Socket通道传输数据，节省掉了建立连接需要耗费的时间。
- 服务器并发数：服务端要同时维持大量连接处于打开状态，就需要能以低性能开销接收高并发数据的架构。此类架构通常是围绕线程或所谓的非阻塞 IO 而设计的。这就与传统服务器围绕 HTTP 请求/响应循环的设计不同。这个时候，我们就会想到nodejs，使用事件机制和异步IO对请求进行处理，提高了服务器的并发能力，并且减少了线程切换带来的开销。

#### 扩展 HTTP 实时性 Web 

- HTTP 轮询 (Polling)：个是最容易实现的而且对浏览器服务器没有特别要求，就是通过不断的向服务器发ajax请求。但这种方法会很浪费带宽和资源，所以不太可取。
- JSONP 轮询：跟http轮询类似，只不过是 JSONP是可跨域的。
- 捎带轮询 (Piggyback Polling)：所谓的 Piggyback 指的是如果后台有什么内容需要推送到前台（即调用页面的js方法），是要等到那个页面进行下一次ajax请求的时候，将需要推送的内容附加在该次请求之后，传回到页面。 
- Comet (长连接，服务器推)：Comet 是一个 Web 应用模型，就是客户端的请求被发送到服务器端后保持一个很长的存活期，直到超时或是有服务器端事件发生。这样服务器就可以在无需显式请求的情况下向客户端发送数据，但这种长时间保持请求打开的功能需要服务器的支持。实现Comet这种模式有2种方法：
  - 流 (streaming)：流的实现也有两种方法：传说中的Forever Iframes 和多部分的 XMLHttpRequest
    - Forever Iframe：这个之前就有听说，就是通过隐藏的iframe的src指向返回服务器端事件的 servlet 路径,每次在事件到达时，servlet 写入并刷新一个新的 script 标签，该标签内部带有 JavaScript 代码，iframe 的内容被附加上这一 script 标签，标签中的内容就会得到执行。 这种方式实现简单，支持iframe的浏览器都可以，但是连接和数据都是通过html标签，不能追踪连接状态以及可靠的错误处理。
    - 多部分的 XMLHttpRequest：是在 XHR 对象上使用某些浏览器（比如 Firefox）支持的 multi-part 标志，Ajax 请求被发送给服务器端并保持打开状态，每次有事件到来时，一个多部分的响应就会通过这同一连接来写入。并非所有浏览器支持。
  - 长轮询 (long-polling)：应该是指服务器端的技术可以保持连接保持打开状态，有事件发生，则响应给客户端，关闭连接，然后再打开一个新的连接。也是有2种实现方式：script 标签 和 XMLHttpRequest 长轮询。
    - script 标签：跟iframe类似，也是返回script脚本执行，可跨域，与iframe有同样的缺点，错误处理缺失，以及连接的不可知不可干涉。
    - XMLHttpRequest 长轮询：我的理解就是发送普通的ajax请求，由服务器端挂起请求，直到某个事件返回响应客户端，客户端继续打开新的请求。这也算是实现Comet的最佳实现了，可以对超时等错误进行追踪，对浏览器几乎没有要求，只是服务器端需要挂起连接的功能。
- FlashSockets：利用嵌入网页的flash程序中的 socket 跟服务器通信，javascript 在通过flash提供的接口获取到XML。从而实现服务器推。但flashsockets需要安装flash插件，并需要843端口。
- WebSocket：是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。

参考资料

- [深入了解HTTP和Socket在实时性Web上的实践](http://ju.outofmemory.cn/entry/23106)
- [关于web通信技术](http://www.tony77.com/archives/431.html)


### Web Storage - Web 存储

#### LocalStorage (本地存储) 与 SessionStorage (会话存储)

LocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。
SessionStorage 与 LocalStorage 的接口类似，但保存数据的生命周期与 LocalStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 SessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，SessionStorage 中的数据就会被清空。

#### Web Storage 与 Cookie

Web Storage 的概念和 Cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
除此之外，Web Storage 拥有 setItem, getItem, removeItem, clear 等方法，不像 Cookie 需要前端开发者自己封装 setCookie，getCookie
Cookie 确实非常小，它的大小限制为4KB左右。Cookie 的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而 Web Storage 仅仅是为了在本地存储数据而生
Cookie 可以设置失效时间；LocalStorage 除非被清除，否则永久保存；SessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除，在多个 Tab 浏览器中， Tab 关闭后重新打开，该会话也会存在
Cookie 的缺陷
- Cookie 的大小被限制在4KB
- Cookie 是随HTTP事务一起发送的，因此会浪费一部分发送 Cookie 时所使用的带宽
- Cookie 操作繁琐复杂

##### Cookie 设置

Cookie 通过 `key=value;` 这样的形式表示的；若 value 出现等号，我们可以使用 `escape()`；若要添加过期时间，我们可以添加一个 `expire=date.toGMTString();`(date 为未来时间)；这时我们也可以通过设置过期时间为过去时间就可以删除该 cookie 了。当我们要指定可访问 cookie 的路径，我们可以通过设置 `path=/` 来设置。

```
function addCookie(name, value, expire) {
  var cookieString = name + '=' + escape(value)

  if(expireHours > 0) {
    var date = new Date()
    date.setTime(date.getTime + expire)
    cookieString = cookieString + ';expire=' + date.toGMTString()
  }

  document.cookie=cookieString
}

function getCookie(name) {
  var strCookie = document.cookie
      arrCookie = strCookie.split(';')

  for (var i = 0, l = arrCookie.length; i < l; i ++) { 
    var arr = arrCookie[i].split('=')
    if (name == arr[0]) {
      return unescape(arr[1])
    } 
  }

  return ''
}
```

#### WebSQL

Web SQL Database (目前只谷歌浏览器支持)：我把它理解成一个 HTML 5 环境下可以用 Javascript 执行 CRUD 的 Web 数据库。WebSql 并不是 HTML5 规范的一部分，这个规范是基于 SQLite。

** CRUD 是指在做计算处理时的增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)几个单词的首字母简写。主要被用在描述软件系统中数据库或者持久层的基本操作功能。

对于简单的数据，使用 sessionStorage 和 localStorage 能够很好地完成存取，但是对于处理复杂的关系型数据，它就力不从心了。这也是 HTML 5 的 "Web SQL Database" API 接口的应用所在。

##### 使用

```
var db = openDatabase('stu', 1.0, '', 1024 * 1024, function() {})

if (db) {
  console.log('Create db success.')
}
else {
  console.log('Create db fail.')
}
```

openDatabase 参数分别是

- 数据库名称
- 版本号 1.0 (only)
- 对数据库的描述
- 设置数据的大小
- 回调函数(可省略)

##### 创建数据表

```
dataBase.transaction(function(tx) {
  tx.executeSql('create table if not exists stu (id REAL UNIQUE, name TEXT)', [], function() {
    console.log('创建stu表成功')
  },
  function() {
    console.log('创建stu表失败:' + error.message)
  })
})
```

executeSql 函数有四个参数，其意义分别是：
- 表示查询的字符串，使用的SQL语言是 SQLite 3.6.19。
- 插入到查询中问号所在处的字符串数据。
- 成功时执行的回调函数。返回两个参数：tx和执行的结果。
- 一个失败时执行的回调函数。返回两个参数：tx和失败的错误信息。

##### 添加数据

```
dataBase.transaction(function (tx) {
  tx.executeSql("insert  into  stu (id, name) values(?, ?)", [id, '徐明祥'], function () {
    console.log('success')
  },
  function (tx, error) {
    console.log('error: ' + error.message) 
  })
})
```

##### 查询数据

```
dataBase.transaction(function (tx) {
  tx.executeSql('select * from stu', [], function (tx, result) {
    // do something...
  },
  function (tx, error) {
    console.log('error: ' + error.message)
  });
});

```

##### 更新数据

```
dataBase.transaction(function (tx) {
  tx.executeSql('update stu set name = ? where id= ?', [name, id], function (tx, result) {
    // do something...
  },
  function (tx, error) {
    console.log('error: ' + error.message)
  })
})
```

##### 删除数据

```
dataBase.transaction(function (tx) {
  tx.executeSql('delete from stu where id= ?', [id], function (tx, result) {
    // do something...
  },
  function (tx, error) {
    console.log('error: ' + error.message)
  })
})
```
##### 删除数据表

```
dataBase.transaction(function (tx) {
  tx.executeSql('drop table stu')
})
```

参考文章

- [THE PAST, PRESENT & FUTURE OF LOCAL STORAGE FOR WEB APPLICATIONS](http://diveintohtml5.info/storage.html)
- [what is the difference between localStorage, sessionStorage, session and cookie?](http://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookie)
- [HTML5开发学习（3）:本地存储之Web Sql Database（附源码）](http://www.cnblogs.com/xumingxiang/archive/2012/03/25/2416418.html)


### Application Cache - 应用缓存

HTML5引入了应用程序缓存技术，意味着web应用可进行缓存，并在没有网络的情况下使用，通过创建cache manifest文件，可以轻松的创建离线应用。

Application Cache带来的三个优势是：

- 离线浏览
- 提升页面载入速度
- 降低服务器压力

#### 使用

Application Cache的使用要做两方面的工作：

- 服务器端需要维护一个 manifest 清单
- 浏览器上只需要一个简单的设置即可

```
<html  manifest="mainfest.appcache">
```

manifest 文件可分为三个部分：

- CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
- NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
- FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

```
# MIME-type: text/cache-manifest (必须设置)
CACHE MANIFEST

# 需要缓存的列表
CACHE:
style.css
imageA.jpg
scriptA.js
http://localhost/applicationcache/scriptB.js

# 不需要缓存的
NETWORK:
imageB.jpg

FALLBACK:
# 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html
imageA.jpg/imageError.jpg
```

#### 缓存大小限制

Application Cache 的尺寸限制统一在 5M，即是当一个文件超过 5M 或累计大小超过5M处于超过5M或以后文件将不会缓存，例如 A.css 4,000k, B.css 2,000k, C.css 100k，则会导致 B.css 的缓存失效。

#### 更新缓存

- 用户清空浏览器缓存
- manifest 文件被修改
- 由程序来更新应用缓存

```
window.applicationCache
.addEventListener('updateready', function() {
  applicationCache.swapCache()
  window.location.reload()
})
```

#### 其他问题

由更新机制来说，首次更新 manifest 时，因为页面加载已经开始甚至已经完成，缓存更新尚未完成，浏览器仍然会使用过期的资源；浏览器是当 Application Cache 有更新时，该次不会使用新资源，第二次才会使用。这个时候 update 事件中执行 window.reload 事件。

参考文章

- [神奇的HTML5离线存储（应用程序缓存）](http://www.cnblogs.com/xjchenhao/p/4032224.html)
- [HTML5应用程序缓存Application Cache](http://www.cnblogs.com/yexiaochai/p/4271834.html)

<!-- HTML5 篇章 END -->
