<!-- title: 前端开发 - 基础知识@协议 -->
<!-- author: <David Jones qowera@qq.com> -->
<!-- date: 2015-05-15 08:50:16 -->
<!-- category: 前端 -->
<!-- tag: 基础知识 -->

## TCP/IP, HTTP, Socket

网络由下往上分为 `物理层`, `数据链路层`, `网络层`, `传输层`, `会话层`, `表示层` 和 `应用层`. IP 协议对应于网络层; TCP 协议对应于传输层; HTTP 协议对应于应用层; TCP/IP 协议是传输层协议, 主要解决数据如何在网络中传输; 而 HTTP 协议对应于应用层, 主要解决如何包装数据, Socket 则是对 TCP/IP 协议的封装和应用

### TCP - 传输控制协议

传输控制协议（Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议.
在因特网协议族（Internet protocol suite）中, TCP 层是位于 IP 层之上, 应用层之下的中间层.

TCP 连接包括三个状态: 连接创建、数据传送和连接终止. 操作系统将 TCP 连接抽象为套接字的编程接口给程序使用, 并且要经历一系列的状态改变.

TCP用三路握手（three-way handshake）过程创建一个连接. 在连接创建过程中, 很多参数要被初始化, 例如序号被初始化以保证按序传输和连接的强壮性.

- 客户端通过向服务器端发送一个握手信号[SYN](http://baike.baidu.com/item/SYN) 来创建一个主动打开, 作为三路握手的一部分. 客户端把这段连接的序号设定为随机数 A.
- 服务器端应当为一个合法的 SYN 回送一个 SYN/ACK. ACK 的确认码应为 A+1, SYN/ACK 包本身又有一个随机序号 B.
- 最后, 客户端再发送一个确认字符 [ACK](http://baike.baidu.com/view/204040.htm). 当服务端受到这个 ACK 的时候, 就完成了三路握手, 并进入了连接创建状态. 此时包序号被设定为收到的确认号 A+1, 而响应则为 B+1.

### HTTP - 超文本传送协议

HTTP 协议即超文本传送协议(Hypertext Transfer Protocol), 是 Web 联网的基础, HTTP 协议是建立在 TCP 协议之上的一种应用.

HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应, 在请求结束后, 会主动释放连接. 从建立连接到关闭连接的过程称为"一次连接".

- HTTP 1.0: 客户端的每次请求都要求建立一次单独的连接, 在处理完本次请求后, 就自动释放连接.
- HTTP 1.1: 可以在一次连接中处理多个请求, 并且多个请求可以重叠进行, 不需要等待一个请求结束后再发送下一个请求.
- HTTP 2.0: 主要减少了延迟, 并没有优化宽带速度
  - 通过 HPACK 算法压缩HTTP头部
  - 将一个 TCP 连接分为多个流(Stream), 每个流可以传输若干消息(Message), 每个消息由若干最小的二进制帧(frame)组成. 通过这样一种流程去实现多路复用
  - 服务器推送: 通过在服务器预解析客户端将需要的资源进行推送资源, 可以减少客户端请求完资源才进行再次建立连接到服务器拿数据, 例如图片等多媒体资源

由于 HTTP 在每次请求结束后都会主动释放连接, 因此 HTTP 连接是一种 "短连接", 要保持客户端程序的在线状态, 需要不断地向服务器发起连接请求. 通常的做法是即时不需要获得任何数据, 客户端也保持每隔一段固定的时间向服务器发送一次 "保持连接" 的请求, 服务器在收到该请求后对客户端进行回复, 表明知道客户端 "在线". 若服务器长时间无法收到客户端的请求, 则认为客户端“下线”, 若客户端长时间无法收到服务器的回复, 则认为网络已经断开.

#### HTTP Status Code

- 1xx 消息
  - 100 Continue 服务器收到请求头, 并且客户端继续发送请求主体
  - 101 Switching Protocols 服务器已经理解了客户端的请求, 并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求.
  - 102 Processing 表示​​服务器已经收到并正在处理请求, 但无响应可用
- 2xx 成功
  - 200 OK 请求已成功, 请求所希望的响应头或数据体将随此响应返回
  - 201 Created 请求已经被实现, 而且有一个新的资源已经依据请求的需要而创建, 且其URI已经随Location头信息返回
  - 202 Accepted 服务器已接受请求, 但尚未处理
  - 203 Non-Authoritative Information 服务器是一个转换代理服务器
  - 204 No Content 服务器成功处理了请求, 没有返回任何内容
  - 205 Reset Content 服务器成功处理了请求, 但没有返回任何内容. 与 204 响应不同, 此响应要求请求者重置文档视图
  - 206 Partial Content 服务器已经成功处理了部分 GET 请求
  - 207 Multi-Status 代表之后的消息体将是一个 XML 消息, 并且可能依照之前子请求数量的不同, 包含一系列独立的响应代码
  - 208 Already Reported DAV绑定的成员已经在（多状态）响应之前的部分被列举, 且未被再次包含
  - 226 IM Used 服务器已经满足了对资源的请求, 对实体请求的一个或多个实体操作的结果表示
- 3xx 重定向
  - 300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息, 每个都有自己特定的地址和浏览器驱动的商议信息. 用户或浏览器能够自行选择一个首选的地址进行重定向
  - 301 Moved Permanently 被请求的资源已永久移动到新位置, 并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一
  - 302 Found 要求客户端执行临时重定向
  - 303 See Other 对应当前请求的响应可以在另一个 URI 上被找到, 当响应于 POST（或 PUT / DELETE）接收到响应时, 客户端应该假定服务器已经收到数据, 并且应该使用单独的GET消息发出重定向
  - 304 Not Modified 表示资源未被修改, 因为请求头指定的版本 If-Modified-Since 或 If-None-Match
  - 305 Use Proxy 被请求的资源必须通过指定的代理才能被访问
  - (x) 306 Switch Proxy 在最新版的规范中, 306状态码已经不再被使用. 最初是指“后续请求应使用指定的代理”
  - 307 Temporary Redirect 在这种情况下, 请求应该与另一个URI重复, 但后续的请求应仍使用原始的URI
  - 308 Permanent Redirect 请求和所有将来的请求应该使用另一个URI重复
- 4xx 客户端错误
  - 400 Bad Request 由于明显的客户端错误
  - 401 Unauthorized 类似于403 Forbidden, 401语义即“未认证”, 即用户没有必要的凭据
  - 402 Payment Required 暂无用处
  - 403 Forbidden 服务器已经理解请求, 但是拒绝执行它
  - 404 Not Found 请求失败, 请求所希望得到的资源未被在服务器上发现, 但允许用户的后续请求
  - 405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源
  - 406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件, 因而无法生成响应实体, 该请求不可接受
  - 407 Proxy Authentication Required 与401响应类似, 只不过客户端必须在代理服务器上进行身份验证
  - 408 Request Timeout 请求超时
  - 409 Conflict 表示因为请求存在冲突无法处理该请求
  - 410 Gone 表示所请求的资源不再可用并且将不再可用
  - 411 Length Required 服务器拒绝在没有定义Content-Length头的情况下接受请求
  - 412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时, 没能满足其中的一个或多个
  - 413 Request Entity Too Large 服务器拒绝处理当前请求, 因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围
  - 414 Request-URI Too Long 请求的URI长度超过了服务器能够解释的长度, 因此服务器拒绝对该请求提供服务
  - 415 Unsupported Media Type 对于当前请求的方法和所请求的资源, 请求中提交的互联网媒体类型并不是服务器中所支持的格式, 因此请求被拒绝
  - 416 Requested Range Not Satisfiable 客户端已经要求文件的一部分（Byte serving）, 但服务器不能提供该部分
  - 417 Expectation Failed 在请求头Expect中指定的预期内容无法被服务器满足, 或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上, Expect的内容无法被满足
  - (x) 418 I'm a teapot 愚人节彩蛋
  - 420 Enhance Your Caim Twitter Search与Trends API在客户端被限速的情况下返回.
- 5xx 服务器错误
  - 500 Internal Server Error 通用错误消息, 服务器遇到了一个未曾预料的状况, 导致了它无法完成对请求的处理
  - 501 Not Implemented 服务器不支持当前请求所需要的某个功能
  - 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时, 从上游服务器接收到无效的响应
  - 503 Service Unavailable 由于临时的服务器维护或者过载, 服务器当前无法处理请求
  - 504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时
  - 505 HTTP Version Not Supported 服务器不支持, 或者拒绝支持在请求中使用的HTTP版本

### TLS 与 SSL - 传输层安全协议(Transport Layer Security) 与 安全套接层(Secure Socket Layer)

两者都是一种安全协议, SSL 是 TLS 的前身
*** 由于 SSL 3.0 出现安全性BUG, 大部分浏览器都不向后兼容并使用 TLS 代替 ***

### HTTPS - 超文本传输安全协议

将 HTTP 建立在 TLS/SSL 之上, 一般称为 HTTP Over TLS, HTTPS 并不是使用 80端口, 而是默认使用 443 端口, 所以为了兼容可以同时监听两个端口

### Socket - 套接字

Socket 是通信的基石, 是支持 TCP/IP 协议的网络通信的基本操作单元. 它是网络通信过程中端点的抽象表示, 包含进行网络通信必须的五种信息：连接使用的协议, 本地主机的 IP 地址, 本地进程的协议端口, 远地主机的 IP 地址, 远地进程的协议端口.

应用层通过传输层进行数据通信时, TCP 会遇到同时为多个应用程序进程提供并发服务的问题. 多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据. 为了区别不同的应用程序进程和连接, 许多计算机操作系统为应用程序与 TCP/IP 协议交互提供了 Socket 接口. 应用层可以和传输层通过 Socket 接口, 区分来自不同应用程序进程或网络连接的通信, 实现数据传输的并发服务.

### 建立 Socket 连接

建立 Socket 连接至少需要一对套接字, 其中一个运行于客户端, 称为 ClientSocket , 另一个运行于服务器端, 称为 ServerSocket.

套接字之间的连接过程分为三个步骤：
- 服务器监听：服务器端套接字并不定位具体的客户端套接字, 而是处于等待连接的状态, 实时监控网络状态, 等待客户端的连接请求.
- 客户端请求：指客户端的套接字提出连接请求, 要连接的目标是服务器端的套接字. 为此, 客户端的套接字必须首先描述它要连接的服务器的套接字, 指出服务器端套接字的地址和端口号, 然后就向服务器端套接字提出连接请求.
- 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时, 就响应客户端套接字的请求, 建立一个新的线程, 把服务器端套接字的描述发给客户端, 一旦客户端确认了此描述, 双方就正式建立连接. 而服务器端套接字继续处于监听状态, 继续接收其他客户端套接字的连接请求.

### Socket 连接与 TCP 连接

创建 Socket 连接时, 可以指定使用的传输层协议, Socket 可以支持不同的传输层协议 (TCP or UDP), 当使用 TCP 协议进行连接时, 该 Socket 连接就是一个 TCP 连接.

### Socket 连接与 HTTP 连接

由于通常情况下 Socket 连接就是 TCP 连接, 因此 Socket 连接一旦建立, 通信双方即可开始相互发送数据内容, 直到双方连接断开. 但在实际网络应用中, 客户端到服务器之间的通信往往需要穿越多个中间节点, 例如路由器、网关、防火墙等, 大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连, 因此需要通过轮询告诉网络, 该连接处于活跃状态.

而HTTP连接使用的是"请求—响应"的方式, 不仅在请求时需要先建立连接, 而且需要客户端向服务器发出请求后, 服务器端才能回复数据.

很多情况下, 需要服务器端主动向客户端推送数据, 保持客户端与服务器数据的实时与同步. 此时若双方建立的是 Socket 连接, 服务器就可以直接将数据传送给客户端; 若双方建立的是 HTTP 连接, 则服务器需要等到客户端发送一次请求后才能将数据传回给客户端, 因此, 客户端定时向服务器端发送连接请求, 不仅可以保持在线, 同时也是在"询问"服务器是否有新的数据, 如果有就将数据传给客户端.


参考资料

- [传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)

-[TCP/IP SOCKET HTTP及HTTPS之间的关系及各自特性之总结](http://kunyali.blog.51cto.com/4890065/1354922)
