<!DOCTYPE html><html><head><base href="/"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="apple-mobile-web-app-title" content=""><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="description" content="David Jones Blog"><meta name="keywords" content="blog,codding,font-end,web,developer,javascript"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="styles/bootstrap.css"><title>Welcome | David Jones</title></head><body><header class="header-container"><div class="container"><a class="brand" href="/" title="blog.davidkk.com">dBLog</a><nav class="nav"><a href="/tag/index.html" title="tags">Tags</a><a href="/archive/index.html" title="archive">Archives</a></nav></div></header><div class="article-container container context"><main class="content"><article class="article"><h1 class="article-title">前端开发 - 基础知识@浏览器</h1><div class="article-infobar"><div class="category"><i class="fa fa-sticky-note-o"></i><a href="/category/前端/1.html" title="前端">前端</a></div><time class="date"><i class="fa fa-calendar-o"></i><span>5/15/2015, 08:50:16</span></time><div class="author">Written by:&nbsp;<a title="&lt;David Jones qowera@qq.com&gt;" target="_blank">&lt;David Jones qowera@qq.com&gt;</a></div></div><section class="article-content"><h1 id="-layout-engine-render-engine-trident-ie">浏览器## 浏览器内核浏览器内核实质指的是 排版引擎 (Layout Engine) 和 渲染引擎 (Render Engine), 不同浏览器所用的内核一般不同- Trident: IE</h1>
<ul>
<li>Gecko: FF</li>
<li>Servo (FF 与 Samsung 开发中):</li>
<li>Presto: Opera (&lt; v12.17)</li>
<li>Webkit: Chrome, Safari, 360极速浏览器, 搜狗浏览器</li>
<li>Blink (webkit的一个分支): Chrome (&gt;= v28.0.1469.0), Opera### 为什么使用 Blink 非 Webkit在多进程架构上, Google 一开始就独自开发了一套沙盒多进程架构, 它和后来由 Apple 主导的 WebKit2 多进程架构差异很大, 为了支持 WebKit2 架构而加入WebCore的大量代码, 对Google不但一点用也没有, 还不得不花时间去处理兼容性的问题, 而 Google 需要修改 WebCore 来支持自己架构的代码又很难进入WebKit主干, 必须很小心处理避免影响其它的Port, 大量的代码不得不通过迂回的方式放在外部处理, 一些没方法在外部处理而需要对WebCore进行大改的特性不得不暂时放弃.
并且, 因为历史原因, WebCore本身一开始就没有多线程或者多进程的概念, 现有的架构对并行处理的支持非常困难, Google也认为必须对WebCore进行整体架构上的大改才能更好的支持并行处理, 更充分利用多核CPU的能力, 避免主线程过度拥挤（虽然现在大部分的WebKit Port都把主要的渲染工作分离到其它线程, 但是主线程仍然需要负担HTML解析, CSS样式计算和匹配, 排版, JS执行等繁重的任务, 为了避免单项任务长时间阻塞主线程, WebCore目前是用延时Timer的方式将一个复杂任务分解成多段来顺序执行, 这种方式即不优雅, 更无法充分利用多核的能力）.
另外, WebCore现在的模块化比较混乱；一些历史遗留的代码和仅仅用于支持某些特定平台的代码导致WebCore代码臃肿不堪；平台相关的处理也没有一个统一的标准和方式, 没有一个很好的抽象层去隔离平台相关和平台无关的部分；WebCore为了可以同时支持不同的JS虚拟机（如JSC和V8）导致了额外的性能开销和妨碍了对JS性能更多的改进；除此以外, 更安全的隔离机制；对现有的网络层进行更大的结构优化等等这些原因也是Google需要自己发展Blink的主要原因.
总之, Chrome有太多激进的改进需要对WebCore进行大改, 而原来那种在外围做文章, 曲线救国的方式再也行不通, 为了能够自行主导架构的演进方向, 避免跟其它Port相互干扰, 相互扯皮给双方带来的困扰和痛苦, 加快开发的速度, 从WebKit主干分离, 自己发展新的浏览器引擎就成了必然的选择.参考文章- <a href="http://www.cnblogs.com/vajoy/p/3735553.html">各主流浏览器内核介绍</a></li>
<li><a href="http://baike.baidu.com/view/1369399.htm">浏览器内核</a></li>
<li><a href="http://blog.csdn.net/rogeryi/article/details/8759199">Why Blink and Why not Blink</a>## 浏览器工作原理### 浏览器结构- 用户界面/User Interface - 包括浏览器主窗口、地址栏、前进/后退/停止/刷新等按钮、收藏夹等, 其他显示的各个部分也都属于用户界面.</li>
<li>浏览器引擎/Browser Engine - 处于用户界面和渲染引擎之间, 负责在两者之间传递操作.</li>
<li>渲染引擎/Rendering Engine - 负责显示请求的内容, 比如HTML, 就负责解析 HTML 和 CSS 内容, 并将解析后的内容显示在屏幕上.</li>
<li>网络/Networking - 用于网络调用, 比如 HTTP 请求.</li>
<li>用户界面后端/UI Backend - 用于绘制基本的窗口小部件, 比如组合框和窗口. 其公开了与平台无关的通用接口, 而在底层使用操作系统的用户界面方法.</li>
<li>JavaScript 解释器. 用于解析和执行 JavaScript 代码.</li>
<li>数据存储. 这是持久层. 浏览器需要在硬盘上保存各种数据, 例如 Cookie. 新的 HTML 规范 (HTML5) 定义了“网络数据库”, 这是一个完整（但是轻便）的浏览器内数据库.<img src="http://feit.topming.com/wp-content/uploads/2014/08/Browser-components.png" alt="浏览器的主要组件">### 渲染引擎主流程#### 渲染引擎的基本流程- 渲染引擎首先会通过网络层去获取请求的内容</li>
<li>获取到内容后, 渲染引擎会进行这样流程：解析 HTML 构建 DOM 树 -&gt; 渲染树的构建 -&gt; 渲染树布局 -&gt; 绘制渲染树</li>
<li>不同的内核渲染流程可能不同<img src="http://feit.topming.com/wp-content/uploads/2014/08/flow.png" alt="渲染引擎的基本流程">- 解析HTML构建DOM树 <code>(DOM Tree)</code><ul>
<li>解析 HTML/SVG/XHTML 文档来构建 <code>DOM 树 (DOM Tree)</code>, 并将各个标签转化为内容树的DOM节点;</li>
<li>解析外部和内部的 CSS 并数据来构建 <code>CSS 规则树 (CSSOM Tree)</code>;</li>
<li>解析 Javascript, 主要是通过 <code>DOM API</code> 和 <code>CSSOM API</code> 来操作 <code>DOM Tree</code> 和 <code>CSSOM Tree</code>;</li>
</ul>
</li>
<li>渲染树的构建 <code>(Rendering Tree)</code><ul>
<li>浏览器引擎会通过 <code>DOM Tree</code> 和 <code>CSSOM Tree</code>来构造<code>Rendering Tree</code>;<ul>
<li><code>Rendering Tree</code> 渲染树并不等同于 <code>DOM Tree</code>, 因为一些像 <code>head</code> 或 <code>display:none;</code> 的东西就没必要放在渲染树中了;</li>
<li><code>CSSOM Tree</code> 主要是为了完成匹配并把CSSOM附加上 <code>Rendering Tree</code> 上的每个 DOM 节点. 也就是所谓的 Frame;</li>
</ul>
</li>
</ul>
</li>
<li>渲染树布局 <code>(Layout)</code><ul>
<li>就可以根据各个 Frame (也就是每个节点) 计算分配在屏幕上的准确坐标；</li>
</ul>
</li>
<li>绘制渲染树 <code>(Painting)</code><ul>
<li>渲染引擎会遍历渲染树, 通过用户界面后端 API 将节点绘制出来.通常为达到更好的用户体验, 渲染引擎会尽快将内容显示在屏幕上, 为此在整个 HTML 文档解析完毕之前, 就会开始构建渲染树和设置布局, 在不断接收和处理来自网络的其余内容的同时, 渲染引擎会将部分内容解析并显示出来#### 浏览器解析 CSS 选择器过程浏览器会会 <code>从右至左</code> 解析样式, 跟 jQuery 查找元素一样. 先找到目标的节点, 然后再往上查找, 因为子元素可能有多个, 但父元素只有一个.#### 阻塞渲染 - CSS 与 JavaScript默认情况下, CSS 被视为阻塞渲染的资源, 这意味着浏览器将不会渲染任何已处理的内容, 直至 CSSOM 构建完毕
当出现媒体特征 (<link ... media="print">), 该 CSS 就不会阻塞渲染, 当符合条件时, 浏览器仍然会阻塞渲染CSSOM 构建时, Javascript 的运行将会暂停
当浏览器遇到 script 标签时, DOM 的构建将暂停, 并等待其脚本执行完为止, 但是仍然会对 script 节点后的资源进行预加载##### 改变阻塞- 将资源都放到最后</li>
</ul>
</li>
<li>添加 <code>async</code> 或 <code>defer</code> 属性 (只针对非 inline-script)<ul>
<li><code>defer</code> 不会打断加载顺序</li>
<li><code>async</code> 只要加载完就立即执行</li>
</ul>
</li>
<li>动态创建标签 <code>document.createElement(&#39;&lt;script&gt;&#39;)</code> 默认已经带上 <code>async</code> 属性, 所以是异步执行并不会阻塞<ul>
<li>动态创建 link 标签在现在浏览器上也不会阻塞 DOM 渲染, 但就旧版本浏览器中可能出现</li>
</ul>
</li>
<li>利用 <code>document.write</code> 与 <code>innerHTML</code> 都会阻塞参考资料</li>
<li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn</a></li>
<li><a href="https://juejin.im/entry/59e1d31f51882578c3411c77">https://juejin.im/entry/59e1d31f51882578c3411c77</a>### Webkit 流程
<img src="http://feit.topming.com/wp-content/uploads/2014/08/wekit-main-flow.png" alt="Webkit 流程">### Mozilla Gecko 流程
<img src="http://feit.topming.com/wp-content/uploads/2014/08/gecko-main-flow.png" alt="Gecko 流程">## 重绘 (redraw) 和重排 (reflow)一个页面载入成功以后形成两个内部数据结构, 一个是 DOM 树（记录页面中的 DOM 节点结构）, 一个是渲染树（控制节点如何渲染）. 当渲染树构建完毕后, 浏览器就可以根据渲染树来绘制页面了, 在这个过程中页面就引发了一次页面重排和重绘, 这是每个网页在加载时都会执行的.
过多的浏览器重绘和重排, 需要付出高昂的性能代价从而大大减低页面的执行效率.
重绘是一个元素外观的改变所触发的浏览器行为, 例如改变 <code>visibility</code>, <code>outline</code>, <code>background</code> 等属性. 浏览器会根据元素的新属性重新绘制, 使元素呈现新的外观. 重绘不会带来重新布局, 并不一定伴随重排.
重排（或叫回流 flush）是 DOM 结构属性发生变化所触发的浏览器行为, 例如改变元素的 <code>width</code>, <code>height</code>, <code>display</code> 等属性, 以及利用 JS 像页面中追加, 删除和修改 DOM 节点. 重排是更明显的一种改变, 会导致整个渲染树的重新计算, 也必然会有重绘, 可见重排必然导致重绘.### 以下操作会产生重排/重绘- 添加或删除可见的 DOM 元素（重排&amp;重绘）</li>
<li>元素位置改变（重排&amp;重绘）</li>
<li>元素尺寸改变（重排&amp;重绘）</li>
<li>内容改变, （重排&amp;重绘）</li>
<li>浏览器窗口改变尺寸（重排&amp;重绘）</li>
<li>字体大小改变（重排&amp;重绘）</li>
<li>字体的颜色, Body的颜色改变（重绘）</li>
<li>同时当获取以下属性时, 因为会造成浏览器强行刷新页面重排队列, 而导致页面重排和重绘, 这些属性和方法有 <code>offsetTop</code>, <code>offsetLeft</code>, <code>offsetWidth</code>, <code>offsetHeight</code>, <code>scrollTop</code>, <code>scrollLeft</code>, <code>scrollWidth</code>, <code>scrollHeight</code>, <code>clientTop</code>, <code>clientLeft</code>, <code>clientWidth</code>, <code>clientHeight</code>, <code>getComputedStyle()</code> (<code>currentStyle()</code> in IE)### 减少浏览器的重排和重绘的方法- 不要经常访问会引起浏览器 flush 队列的属性, 需要的时候先缓存处理</li>
<li>将需要多次改变的元素的样式属性的, 通过一次改变完成<ul>
<li>不要把DOM结点的属性值放在一个循环里当成循环里的变量</li>
</ul>
</li>
<li>尽可能修改层级比较低的 DOM</li>
<li>将新建的 dom 节点操作完毕后在插入到 body 中</li>
<li>把 DOM 离线后修改<ul>
<li>将页面中需要操作的节点先隐藏<code>display:none</code>, 操作完毕后在显示</li>
</ul>
</li>
<li>尽量减少持续改变和动态变化的效果. 比如 jquery 的 animate, 尽量使用 CSS3 动画效果来实现</li>
<li>为动画的 HTML 元件使用 fixed 或 absoult 的 position</li>
<li>不要使用 Table 布局<ul>
<li>因为可能很小的一个小改动会造成整个 table 的重新布局检测工具- <a href="http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/">Google Chrome Timeline</a>参考文章- <a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
</ul>
</li>
<li><a href="http://feit.topming.com/how-modern-web-browsers-work/">现代浏览器的工作原理</a></li>
<li><a href="http://coolshell.cn/articles/9666.html">浏览器的渲染原理简介</a></li>
<li><a href="http://www.aliued.cn/2012/11/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98repaints%E4%B8%8E%E9%87%8D%E6%8E%92reflows.html">页面重构应注意的repaint和reflow</a></li>
</ul>
</section><div class="article-widgets"><div class="tags"><i class="fa fa-tags"></i><a href="/tag/基础知识/1.html" title="基础知识">基础知识</a></div></div></article><nav class="pagination"><ul class="pagination-simple"><li><a href="/article/前端开发 - 基础知识@小程序.html" title="前端开发 - 基础知识@小程序"><span>Previous</span><span>前端开发 - 基础知识@小程序</span></a></li><li><a href="/article/前端开发 - 基础知识@网络安全.html" title="前端开发 - 基础知识@网络安全"><span>Next</span><span>前端开发 - 基础知识@网络安全</span></a></li></ul></nav><div class="comments"><div class="disqus-plugin"><div id="disqus_thread"></div><script>!(function() {
  var d = document;
  s = d.createElement('script');
  s.src = '//davidkk.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  !(d.head || d.body).appendChild(s);
})();</script></div></div></main></div><footer class="footer-container"><div class="container"><div class="about"><a class="link" href="https://github.com/DavidKk" title="Github" target="_blank"><i class="fa fa-github-alt"></i></a><a class="link" href="http://codepen.io/DavidJones" title="CodePen" target="_blank"><i class="fa fa-codepen"></i></a><a class="link" href="https://twitter.com/Mr_DavidJones" title="Twitter" target="_blank"><i class="fa fa-twitter"></i></a><span><i class="fa fa-heart"></i></span><a class="link" href="https://plus.google.com/u/0/111899862347999076942" title="Google Plus" target="_blank"><i class="fa fa-google-plus"></i></a><a class="link" href="http://weibo.com/307853201" title="微博" target="_blank"><i class="fa fa-weibo"></i></a><a class="link" href="mailto:qowera@qq.com" title="E-Mail"><i class="fa fa-envelope-o"></i></a></div><p class="copyright clearfix">Powered by&nbsp;<a href="/">davidkk.com</a>&nbsp;&copy; 2016
,&nbsp;<a href="/static/sitemap.xml" title="Sitemap">Sitemap</a></p></div></footer><script src="scripts/index.js"></script><script id="dsq-count-scr" src="//davidkk.disqus.com/count.js" async></script></body></html>