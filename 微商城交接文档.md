<!-- title: 微商城交接文档 -->
<!-- author: <David Jones qowera@qq.com> -->
<!-- date: 2015-05-18 16:18:09 -->
<!-- category: 交接 -->
<!-- tag: 交接 -->

# 微商城交接文档

#### 贡献者: (前端开发工程师)David Jones qowera@qq.com, ...
#### 最后更新: 2015-05-18 17:01:26
#### 当前版本: v1.0.0

微商城交接文档，若后面有所修改可能导致与本文档不正确。若更新版本建议可以按照格式或使用更多版本管理工具进行编写文档。
接手人员请选择性继承变编辑以便后面更多更好地交接。


## 流程

微商城分为3个项目:

- wmall.cmpower.cn
  - Name: 前台项目
  - Git: ssh://git@weili:/wmall.cmpower.cn.git
- m.wmall.cmpower.cn
  - Name: 商家后台项目
  - Git: ssh://git@weili:/m.wmall.cmpower.cn.git
- api.wmall.cmpower.cn
  - Name: 接口项目
  - Git: ssh://git@weili:/api.wmall.cmpower.cn.git


### 商品

商品分为 `单规格商品`(包括站外商品) 和 `多规格`。
单规格商品没有规格。即 sku指向 商品ID。
多规格商品是按照规格来确定一件商品的，不同的规格值组合起来的对应不同的 `skuId`。
一般商品可以直接 `上架`，那么用户就可以直接在商城看到该商品；
若商品为 `下架状态`，则用户无法在商品列表看到该商品，但是仍然能通过URL进入该商品，并进行购买(BUG)。
商品可以不进行下架直接修改，并且立即更新到详情页与购物车(...)，订单指向的商品不会有任何修改。


- 商品类目 (必填，有层级关系，不能修改)
- 商品分组 (必填，一个商品可以同时拥有多个分组)
- 商品购买方式 (必填，商城内部购买-默认|外部链接购买，不能修改)
- 商品规格 (必填，单规格|多规格，不能修改，只有商城内购买的商品才有，根据类目确定的)
- 商品名称 (必填)
- 商品价格 (必填)
- 市场价格 (必填)
- 商品库存 (必填，内部购买才有。当商品为外部购买商品时，库存为 10000)
- 商品图片 (必填，UI没有规定图片大小，图片没有图片服务器，过大会导致上传失败)
- 外部购买地址 (必填，外部购买才有)
- 营销用语 (选填)
- 商品简介 (选填)
- 配送方式 (必填，物流配送|到店自提，多选，只有商城内部购买才有)
- 支付方式 (必填，现金POS#支持货到付款及营业自取 | 微信支付|支付宝支付|银联支付，只有商城内部购买才有，暂时只支持现金POS)
- 运费设置 (必填，包邮|统一邮费，只有商城内部购买才有)
  - 快递 (选填)
  - EMS (选填)
  - 平邮 (选填)
- 商品详情 (选填)
- 访问量 (暂时没做该功能)
  - PV
  - UV
- 销量
- 创建时间


#### 商品分组

商品分组初始化就拥有一个默认分组，默认分组没有创建时间。默认分组可以修改名字，不能删除。

属性:

- 分组名 (新增修改必填)
- 排列方式 (新增修改必填)
- 排列样式 (新增修改必填)
- 商品数
- 访问量
  - PV (暂时还没做)
  - UV (暂时还没做)
- 创建时间


### 购物车

购物车通过 `用户ID` 与 `商城ID` 来确定某个购物车。购物车每一个项目我们叫他为购物车ID，这里很容易混淆，正确命名
应该为购物车项目ID，建议更改名称更容易明白。

每一个购物车都根据商城ID来确定，所以不同的用户在不同的商店中拥有不同的购物车，同时购物车不共享商品，也不能购买结算
其他购物车。当用户到某个商店ID才能看到那个购物车。

示意图:
```
[userA] -> [merchantA] -> [cartA]
        -> [merchantB] -> [cartB]
```

购物车必须通过 `编辑` 才能修改商品数量与删除商品。
每一次修改商品数量的时候都会发送一条请求，当有返回结果的时候才能再次编辑该商品数量。

购物车根据 `配送方式` 不同分为两类结算方式，一种为 `物流配送`，另外一种是 `到店自提`。

当某些商品属于 `物流配送` 或 `到店自提` 的时候，一个订单只能提交那部分的商品，不能提交多任何其他的不同种类的商品。(当前还没有完成，因为UI还没出该页)

因此当前购物车暂不可用，商品只能通过 `马上购买` 到达支付页面。


#### 到店自提

- 营业厅
- 取货时间
- 支付方式 (只有到营业厅支付)

#### 物流配送

- 收货人地址 (必填)
- 结算的商品 (必填)
- 配送方式 (必填)
- 运费 (通过后台接口拿来的)
- 支付方式 (必填)


### 订单

#### 订单状态

- 待付款 (已经申城订单，1)
- 待发货 (用户已经给钱的情况下，`货到付款`，还没发货, 2)
- 已发货 (商家已经发货了，也可以称为 `待收货`，在不同环境称呼不同而已，3)
- 已收货 (用户已经收到货了，4)
- 已关闭 (已经没有什么问题了，可以关闭订单，5)
- 已取消 (用户不买该商品或拒收，可以直接取消，6)

到店自提 不知道状态是什么情况。

#### 维权 (在买家的角度来看，就是前台来看)

##### 维权状态 (商家)

- 未进行维权 (用户还没进行任何维权申请, 0)
- 维权中 (用户已经申请维权, 1)
- 同意 (商家已经同意维权申请, 2)
- 拒绝 (商家已经拒绝维权申请, 3)

##### 维权类型 (用户)
 
- 未收到退款/退货 (已经申请退款/退货, 1)
- 已收到退款/退货 (确认已经收到退款/退货, 2)
- 继续申请 (没有得到同意退款/退款，再次申请, 3)
- 维权结束 (双方都搞定了, 4)

#### 维权 (在用户的角度来看，就是后台来看)

##### 维权状态 (商家)

- 未进行维权 (用户没有任何动静, 1)
- 处理中 (用户提出了维权申请, 2)
- 已处理 (商家已经同意或拒绝该维权申请, 3)

##### 维权类型 (用户)

- 退款/退货/退款退货 (1)
  - 退款: 通过 `已付款` 的订单，当订单已经给钱了，货还没到用户手上，用户不想买的时候可以退款。
  - 退货: 没有通过 `已付款`的订单，当订单为货到付款时，用户不想买的时候可以退货。
  - 退款退货: 当通过 `已付款` 和 `已收货的情况下`，用户不想要商品可以申请退款退货。
- 换货 (当商品出现问题的时候，可以跟商家申请换货, 2)
- 维修 (当商品出现问题的时候，可以跟商家申请维修, 3)


#### 用户不同状态拥有的功能

```
# `$` 表示功能

已在维权 (complaint_type != undefined，表示不是未在维权)
  $ 追加说明
  # 维权 START
  已申请维权，维权中但未收到答复 (complaint_status > 1)
    # 缺少一个商家已经同意的判断
    已申请退款/退货 (complaint_type == 1)
    # 货到付款情况下如何完成退款
      已付款，待发货 (order_status == 2)
        $ 未收到退款 (未收到暂时不知道如何操作)
        $ 已收到退款
      已发货，待收货 (order_status == 3)
        $ 未收到退货
        $ 已收到退款
      已收货 (order_status == 4)
        $ 未收到货款
        $ 已收到货款
    卖家不同意，申请换货或申请维修(现在忽略)，订单还不在关闭状态((complaint_type == 2 || complaint_type == 3) && order_status != 5)
      $ 维权结束
      $ 继续维权
  # 维权 END

  # 交易流程 START
  待付款 (order_status == 1)
    $ 取消订单
    $ 马上支付
  待发货 (order_status == 2)
    订单不是货到付款 (payment_type != 1)
      $ 申请退款
  已发货，待收货 (order_status == 3)
    $ 确认收货
    # 中间过程可能再细分，到手了与期间
    订单不是货到付款 (payment_type != 1)
      $ 申请退货
  交易成功 (order_status == 4)
    $ 退款退货
    $ 申请换货
    $ 申请修理
    $ 关闭订单
  已经取消订单 (order_status == 6)
    $ 关闭订单
  # 交易流程 END
```

### 支付

略...


## 前端

`wmall.cmpower.cn` 和 `m.wmall.cmpower.cn` (后面统称为: 前端项目) 项目均为全静态项目。项目配置到一个 nginx 服务器中，
nginx 根据网址提供路由指引到某一静态文件上HTML文件。前端项目均使用 `grunt` 项目生成工具来生成项目。

前台:
Client: seajs + jquery(新分支 zepto 代替了) + artTempalte + bootstrap(建议去除)
Server: nginx + 纯静态项目 => (nodejs + grunt)

PS:
有分支 `branch q`，还没有通过任何测试，所以上之前应该把所有功能点再检测一次，建议等UI优化出了的时候再统一上，
因此有新需求的时候需要把新旧分支同时进行修改。

后台:
Client: angular + bootstrap
Server: nginx + 纯静态项目 => (nodejs + grunt)

项目结构：

```
前端项目结构(两个前端平台都差不多)
node_modules/                     # node 第三方库
client/(or called src)            # 客户端文件夹
  audio/                          # 声音文件
  css/                            # 第三方样式库(如 `bootstrap`)
  fonts/                          # 字体文件
  ico/                            # 图标文件
  images/                         # 图片文件
  jade/
    partials/                     # 局部
    tpls/                         # 模板
    views/                        # 页面
  less/
    components/                   # 组件
    core/                         # 核心
    effects/                      # 效果
    mixins/                       # 混淆
    partials/                     # 局部 (例如 header, footer, nav 那些公用模块)
    resets/                       # 重写
    script-components/            # 含js的组件
    utility/                      # 工具
    variables/                    # 定义的变量
    views/                        # 页面
  scripts/
    app/(or called controllers)   # 页面脚本
    conf/                         # 配置
    helpers/                      # 辅助函数
    libraries/                    # 库(包括第三方)
    models/                       # 模型(主要封装后端调用)
    services/                     # 服务($http等)
    ui/                           # UI
      template/(only in 'm')      # UI模板
    app.js(only in 'wmall')       # 入口文件
  swf/                            # swf 文件
  sprites/                        # 精灵图片
    images/                       # 图片
    tempalte/                     # LESS模板
      sprites.less.mustache
assets/                           # 最终生成的静态文件
views/                            # 最终生成的HTML
```

### 基础

安装 nodejs + npm + grant-cli
现在多人开发会容易导致 Git 上的生成文件冲突。因此我们最好可以通过服务器运行 node 来解决这一问题。
而且某些接口很有针对性地指向某一页面，造成接口耦合。


##### 编译

```
# 开发
grunt dev

# 发布
grunt rel
```

##### 建议

服务器环境仍然运行 grunt

```
# 开发 (不做任何压缩)
grunt develop

# 发布 (发布前包括压缩，测试等)
grunt release

# 生产环境 (压缩，测试清除缓存等，同步到各个服务器)
grunt production
```

### 后台

#### 所有商品

脚本位置 `scripts/controllers/index/products.js`

有三大模块，分别是 `出售中的商品`，`仓库中的商品`和`售完的商品`；
我们定义他为一个控制器 `Product.DatatableController`，即三个模块输出数据均为一个控制器；
我们根据 `ng-init` 初始化实现不同模块加载不同的内容，但是加载逻辑是一样的。

#### 商品分组

只是普通输出。


#### 订单管理

脚本位置 `scripts/controllers/index/order.js`

订单管理包括三个页面 `在线支付订单`，`货到付款订单`，`维权订单`。
而其中三个页面均部分拥有，`所有订单`，`待付款`，`待发货`等订单状态帅选模块。
而这些页面与这些模块都是通过 `Order.DataTableController` 控制器完成的。
也是根据 URL 地址获取不同类型/状态的订单。

#### 发布商品

发布与编辑商品，是使用不同的控制器的 `ProductEditor.CreateController`(新增)，`ProductEditor.EditController`(编辑)

当商品是多规格商品时，要渲染出所有的规格。这里注意了 (*)：

因为 angular 模板引擎是通过绑定节点进行渲染的。
因此我们没有办法通过 `递归` 进行 table 渲染，因为 table HTML 格式如下

```
table
  tbody
    tr
      td(rowspan="2") ...
    tr
      td ...
      td ...
```

因此我们只能通过获取各个列需要输出多少个元素，且获得那些需要合并的的数据。
这样我们会生成一个 C(a,b) a*(a-1)*(a-2)*... 的图形。

最终生成的结果其实是一个这样的表格，只是前面的格子合并了而已

```
_
  _
    _
      _
        _ 
          _
```

具体还需参考 `scripts/controllers/index/productEditor.js` 中 `ProductEditor.MutipleSpecController` 控制器末尾。
已经根据代码详细说明了数据详细了。


#### 店铺装修

因为有一个店铺装修，因此我们将各个部件都做成独立的控件，例如：`焦点图`，`功能模块`，`商品列表`。
并给予一个展示样式的接口给后台进行装修配置。通过同域设置，可以使后台直接调用这些展示页面的接口再进行相关渲染。

具体还是参考代码 `scripts/controllers/decorate.js` 里面已经非常详细的说明。

#### 添加/编辑商品分组

这里是同过前台页面的接口渲染预览效果。跟店铺装修原理一样。


### 后台脚本简述

后台是将 javascript 文件合并成一个文件的，因此合并的时候可能会很缓慢，而且公共的没有抽出来。而其他页面的模块可能在这里并没有使用。

#### 命名

`controllers/` 目录下是单页面模块名称的目录。例如 `controllers/error/` 表示 `error` 这个页面； `controllers/index/` 表示 `index` 这个页面。
每个页面下都有一个 `app.js` 入口文件。我们通常将它命名为 `xxx.app` 例如 `index/app.js` => `angular.module('index.app', [...])`。
而 `controllers/` 目录下的其他所有模块的控制器均以所在页面的文件夹作为前缀 `index/address.js` => `angular.module('index.address', [...])`。
除了 `controllers/`， `helpers/` 和 `libs/` 目录，其他模块均以模块文件夹名称作为前缀，例如 `models/address.js` => `angular.module('models.address', [...])`。
所有控制器必须以 `Controller` 作为后缀命名且第一个字母要大写，例如 `IndexController`。

#### 运行

```
# 开发
grunt dev

# 发布
grunt rel
```

后面在服务器上 node 的时候，可以直接在服务器上添加 grunt task。

```
# 开发 
grunt develop

# 发布
grunt release

# 生产环境
grunt production
```

#### model 服务

文件位置位于 `scripts/services/model.js`

该服务器是对 angluar $http 服务的再次封装。

```
var promise = $model
.get('/merchant/address/index/?address_type=2', data)
.query()

promise
.then(function() {
  // do something...
})
.catch(function() {
  // do something...
})
.finally(function() {
  // do something...
})
```

#### 验证服务 `$validator`

文件位置 `scripts/services/validator.js`
虽然不是 UI 但是他提供一个 `directive`，主要作用是验证表单某个元素是否有效。
绑定的事件是 `focus` 与 `blur`，在 `function validate() {}` 可以添加一些自定义的验证方式。
暂时拥有就这三个，`required`, `noequal`, `equal`。

并且对外提供一个 `provider` `$validator`，因此我们可以在 `scripts/conf/validator.js` 下添加自定义的验证方法。

```
.config([
  '$validatorProvider',
  function($validatorProvider) {
    $validatorProvider.add('url', function(url) {
      return angular.isUrl(url) || 'regexp';
    });
  }
])
```

这样我们就可以在试图中使用该验证了

```
# 下面为验证商品名称是否合法

.form-group(ng-class="{\
  'has-error': form.name.$dirty && form.name.$invalid,\
  'has-success': form.name.$dirty && form.name.$valid }")
  label.control-label.col-sm-4 商品名称：
  .col-sm-4
    input.form-control(validator, required, ng-model="name", ng-type="productname", name="name", type="name", placeholder="请输入商品名称")

    .form-control-prompt.cyan.top(ng-class="{ open: form.name.$focus && form.name.$pristine }")
      span.content 请输入商品名称。

    .form-control-prompt.red.top(ng-class="{ open: form.name.$focus && form.name.$invalid }")
      span.content(ng-show="form.name.$error.required") 商品名字不能为空
      span.content(ng-show="form.name.$error.regexp") 商品名字不能超过20个字。
```

#### UI `promptbox`

文件位于 `scripts/ui/promptbox.js`

当我们引入了 promptbox 模块时，我们可以使用广播 `broadcast` 来调出弹出框。

```
$rootScope.$broadcast('notify', 'What a fucking day.', 'success');
```

#### 部分UI需要注意

`ngHighcharts` 需要引入 `jQuery`, `hightchart`
`ngClipboard` 需要引入 `swf/ZeroClipboard.swf`
`ngIscroll` 需要引入 `iscroll`
`messagebox` 并没有完成，主要是退出弹出框，HTML文件在 `jade/partials/messageBox.jade`，还有声音文件 `audio/alert.mp3` `audio/alert.ogg`，样式并没写完，可以删除掉。

### 样色

`views/` 和 `partials/` 目录下有很多个目录，这些都表示独立页面模块；他们还可以根据不同分辨率完成不同的样式布局。
例如 `partials/navigation/` 我们可以定义4个文件来描述不同情况下样式应该如何变化：

```
partials/
  navigation/
    main.less
    desktop.less
    tablet.less
    mobile.less
```

修改 `scripts-components/` 目录下文件时，注意某些样式是否要等到 `javascript` 调用的时候才会输出。



### 前台

地址必须带上商铺ID，否则会调转到404页面。
若没有关注相应的公众号，会调转到关注页面。

#### 首页

按装修的顺序与店铺信息渲染页面。

#### 详情页面

若没有带上商品ID，或者该商品不存在的时候，都会调转到404页面。
有几种类型商品，`站内商品`和`站外商品`，其中`站内商品`有包括单规格商品与多规格商品。

选择规格，因为选择会导致先后顺序的出现 `1,2,3` 与 `2,3,1` 其实是一个，而且我们必须预测我们用户能否选择下一个规格，
例如只有 `1,2,3,4` 可选，我们可以进行处从 [A].concat([B]) === [B] 如果等于[B]，我们可以说[A]属于[B]这个集合。
这个方法在很多地方都有用到。不用使用 `jQuery.unique` 因为它使针对节点来做的。最好还是自己再写一个。

```
  if (!$.isFunction($.unique)) {
    $.unique = function(a) {
      var old = $.unique

      if (!!a[0].nodeType) {
        return _old.apply(this,arguments)
      }
      else {
        return $.grep(a, function(v, k) {
          return k === $.inArray(v, a)
        })
      }
    }

    // 兼容
    $.unique.noConflict = old    
  }
```

#### 购物车

购物车页面有两个页面，`购物车商品选择页面` 与 `购物车结算页面`，两个页面通过传递要购买的的 `购物车项目ID` 来确定结算页面要结算什么东西。
当用户通过 `立即购买` 按钮购买商品时，会跳过 `购物车商品选择页面` 直接打到 `购物车结算页面`。

#### 支付完成页面

支付页面失败样式已经完成了，因为网速等原因，一切支付成功的订单都视为成功支付。因此支付完成页面只是输出一下订单号与订单信息。

#### 个人中心

个人中心主要是订单数量综合起来的数据。没什么特殊的东西。

#### 订单页面

订单页面根据订单状态可以渲染不同的功能。例如待付款的时候，显示 `马上支付` 和 `取消订单`。根据上面那个示意图来输出。

#### 收货地址/营业厅地址

新增与修改是同一个页面，用相同的验证，只是编辑的时候要先获取数据，提交的时候提交到不同的接口。
编辑的时候当地址不存在，会弹出提示，并跳转到地址列表页面。
该页面与地址列表页面一样，拥有一个 go 的 URL 参数，encode 了的，当点击提交或者返回的时候会跳转到 go 指定的页面。这里主要给支付页面修改地址使用。

#### 收货地址/营业厅地址 列表页面

只是普通的输出，可以设置为默认地址。
当 go 参数不存在的时候会，返回按钮变成返回个人中心。

### 前台项目代码简述(这里只描述新分支)

#### 脚本部分

虽然不是优化的方式，但是下面将列出当前版本实际的情况。优化之前已经说过了（暂时略时间不多了）

##### 命名

所有 `app/` 下的模块均使用与文件名一致的命名，例如 `app/address.js` we define it: `define('address', [...], function() {})`
所有 `conf/` 与 `services/` 目录下的模块，我们均把他们带上 `$` 前缀，例如 `conf/config.js` => `define('$config', [...], function() {})`，`services/hash.js` => `define('$hash', [...], function() {})`。
所有 `models/` 目录下的模块，我们均把他们带上 `Model` 后缀，例如 `models/address.js` => define('addressModel', [...], function() {})
`libraries` 下的目录是放如 `jQuery` 那些库的。

优化命名，可以继续缩写 例如 `application` => `app`, `config` => `conf`；
但是不要加上复数，例如 `model` => `models` (x) 建议直接使用 `model`；

##### 运行

app.js 是入口文件

里面创建部分自动加载的模块。包括基础路由，定义一些关于应用的基本方法 (例如：所有 href 都会自动检测 `m` 参数是否存在，并自动带上)并执行当前页需要的主模块。
还有个功能就是自动检测 ui 模块，只要模块带上 `ui.` 即在 ui 文件夹先就会自动加载。

`app/` 目录下的脚本是针对每一个页面的，生成的脚本在 `assets/scripts/main/` 目录下；
其他目录下的模块均会合并成 `wmall-version.js` 放在 `assets/scripts/` 目录下；

##### 路由

前端路由是 `David Jones` 写的一个小型路由 `scripts/services/route.js`。主要依赖有：
`scripts/services/hash.js`
`scripts/services/history.js`
`scripts/services/location.js` 这个主要依赖上面两个模块，而 `route.js` 主要依赖 `location.js`。

主要用法介绍

```
# conf/config.js

var $routeProvide = require('$routeProvide');
$routeProvide.useHTML5(true);

# app/..
var $route = require('$route');

$route
.when('/cart/', function() {
  require.async('cart.index')
})
.when('/cart/payment', function() {
  require.async('cart.payment')
})
.digest()

# digest 是执行，相当于 `trigger`
```

优化：

建议可以选择第三方路由，这样可以省略维护成本。

##### $model

AJAX 的再次封装，具体还是看代码，灰常清晰，代码在 `scripts/services/model.js`

调用方法

```
# 我们可以写 `model` 模块，都放在 `models/` 目录下
var promise = $model
.request('GET', '/customer/customer_address/get_address_info/', { shipping_type: type || 1 })
.query()

# 我们可以调用 `model` 模块
promise
.then(func)     # 成功，当返回状态为正确且 `code == 0` 的时候
.fail(func)     # 除了成功之外任何情况均表示失败
.always(func)   # 总是运行
```

##### 视图服务

视图服务文件在 `services/view.js`，对 模板引擎的再次封装，也可以说是一种模块化处理。

用法
```
var $view = require('$view')
    , promise = $view.loadView('...') # 预编译

promise.render({}) # 渲染

# 里面还有 `busy` 方法，可以使页面停留在 `loading` 过程中。
$view.busy()
```

##### 本地化服务 `$locale`

此服务作用不是很大，在本项目中并没用实际用到，但是删除的时候需要测试一下，主要是处理某些状态输出说明，例如订单状态描述之类的。

```
var $locale = require('$locale');

_.Locale({
  PAYMENT_TYPE: {
    PAY_IN_CASH:        '货到付款',
    PAY_IN_WECHAT:      '微信支付',
    PAY_IN_ALIPAY:      '支付宝支付'
  }
})
```

##### 本地存储服务 `$storage`

一些数据我们可以先保存在本地，当下一次打开的时候可以让客户更快看到数据，然后并行更新数据。当然数据必须有选择行保存。

```
var $storage = require('$storage')
$storage
.get('address_source')
.then(function(data) {
  // do something...
})
```

##### UI

在 `scripts/ui/` 目录下

略。

### 规范参考 Google 前端开发规范吧。

### 优化

之前已经说过了，可以参考
[webSPA-seed](https://github.com/DavidKk/webSPA-seed)


## 后端

环境: Linux + Nginx + PHP + Mysql + Redis
框架: Codeigniter


### 问题

命名规范并未统一

```
# 规格
spec
spe

# 联表查询时，ID并没转换
id
product_id

# 部分接口 GET/POST 模糊不清，建议不要使用 `get_post`，明确接口
# 建议模仿 RESTful...
# 其他 略
```
