<!-- title: 前端开发 - 基础知识 -->
<!-- author: <David Jones qowera@qq.com> -->
<!-- date: 2015-05-15 08:50:16 -->
<!-- category: 前端 -->
<!-- tag: 基础知识 -->

# [backup] 前端开发 - 基础知识

## 浏览器

### 浏览器内核

- Trident: IE
- Gecko: FF
- Servo (FF 与 Samsung 开发中):
- Presto: Opera (< v12.17)
- Webkit: Chrome, Safari, 360极速浏览器, 搜狗浏览器
- Blink (webkit的一个分支): Chrome (>= v28.0.1469.0), Opera

#### 为什么使用 Blink 非 Webkit

在多进程架构上，Google一开始就独自开发了一套沙盒多进程架构，它和后来由Apple主导的WebKit2多进程架构差异很大，为了支持WebKit2架构而加入WebCore的大量代码，对Google不但一点用也没有，还不得不花时间去处理兼容性的问题，而Google需要修改WebCore来支持自己架构的代码又很难进入WebKit主干，必须很小心处理避免影响其它的Port，大量的代码不得不通过迂回的方式放在外部处理，一些没方法在外部处理而需要对WebCore进行大改的特性不得不暂时放弃。
并且，因为历史原因，WebCore本身一开始就没有多线程或者多进程的概念，现有的架构对并行处理的支持非常困难，Google也认为必须对WebCore进行整体架构上的大改才能更好的支持并行处理，更充分利用多核CPU的能力，避免主线程过度拥挤（虽然现在大部分的WebKit Port都把主要的渲染工作分离到其它线程，但是主线程仍然需要负担HTML解析，CSS样式计算和匹配，排版，JS执行等繁重的任务，为了避免单项任务长时间阻塞主线程，WebCore目前是用延时Timer的方式将一个复杂任务分解成多段来顺序执行，这种方式即不优雅，更无法充分利用多核的能力）。
另外，WebCore现在的模块化比较混乱；一些历史遗留的代码和仅仅用于支持某些特定平台的代码导致WebCore代码臃肿不堪；平台相关的处理也没有一个统一的标准和方式，没有一个很好的抽象层去隔离平台相关和平台无关的部分；WebCore为了可以同时支持不同的JS虚拟机（如JSC和V8）导致了额外的性能开销和妨碍了对JS性能更多的改进；除此以外，更安全的隔离机制；对现有的网络层进行更大的结构优化等等这些原因也是Google需要自己发展Blink的主要原因。
总之，Chrome有太多激进的改进需要对WebCore进行大改，而原来那种在外围做文章，曲线救国的方式再也行不通，为了能够自行主导架构的演进方向，避免跟其它Port相互干扰，相互扯皮给双方带来的困扰和痛苦，加快开发的速度，从WebKit主干分离，自己发展新的浏览器引擎就成了必然的选择。

参考文章

- [各主流浏览器内核介绍](http://www.cnblogs.com/vajoy/p/3735553.html)
- [浏览器内核](http://baike.baidu.com/view/1369399.htm)
- [Why Blink and Why not Blink](http://blog.csdn.net/rogeryi/article/details/8759199)

### 浏览器工作原理

#### 浏览器结构

- 用户界面/User Interface - 包括浏览器主窗口、地址栏、前进/后退/停止/刷新等按钮、收藏夹等，其他显示的各个部分也都属于用户界面。
- 浏览器引擎/Browser Engine - 处于用户界面和渲染引擎之间，负责在两者之间传递操作。
- 渲染引擎/Rendering Engine - 负责显示请求的内容，比如HTML，就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
- 网络/Networking - 用于网络调用，比如 HTTP 请求。
- 用户界面后端/UI Backend - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- JavaScript 解释器。用于解析和执行 JavaScript 代码。
- 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

![浏览器的主要组件](http://feit.topming.com/wp-content/uploads/2014/08/Browser-components.png)

#### 渲染引擎主流程

###### 渲染引擎的基本流程

- 渲染引擎首先会通过网络层去获取请求的内容
- 获取到内容后，渲染引擎会进行这样流程：解析HTML构建DOM树 -> 渲染树的构建 -> 渲染树布局 -> 绘制渲染树 
- 不同的内核渲染流程可能不同

![渲染引擎的基本流程](http://feit.topming.com/wp-content/uploads/2014/08/flow.png)

- 解析HTML构建DOM树 `(DOM Tree)`
  - 解析HTML/SVG/XHTML文档来构建`DOM树 (DOM Tree)`，并将各个标签转化为内容树的DOM节点；
  - 解析外部和内部的CSS并数据来构建`CSS规则树 (CSS Rule Tree)`；
  - 解析Javascript，主要是通过`DOM API`和`CSSOM API`来操作`DOM Tree`和`CSS Rule Tree`；
- 渲染树的构建 `(Rendering Tree)`
  - 浏览器引擎会通过`DOM Tree`和`CSS Rule Tree`来构造`Rendering Tree`；
    - `Rendering Tree`渲染树并不等同于`DOM Tree`，因为一些像Header或display:none的东西就没必要放在渲染树中了；
    - `CSS Rule Tree`主要是为了完成匹配并把CSS Rule附加上`Rendering Tree`上的每个DOM节点。也就是所谓的Frame；
- 渲染树布局 `(Layout)`
  - 就可以根据各个Frame（也就是每个节点）计算分配在屏幕上的准确坐标；
- 绘制渲染树 `(Painting)`
  - 渲染引擎会遍历渲染树，通过用户界面后端API将节点绘制出来。

通常为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，为此在整个 HTML 文档解析完毕之前，就会开始构建渲染树和设置布局，在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。

###### Webkit 流程
![Webkit 流程](http://feit.topming.com/wp-content/uploads/2014/08/wekit-main-flow.png)

###### Mozilla Gecko 流程 
![Gecko 流程](http://feit.topming.com/wp-content/uploads/2014/08/gecko-main-flow.png)


### 重绘 (redraw) 和重排 (reflow)

一个页面载入成功以后形成两个内部数据结构，一个是DOM树（记录页面中的DOM节点结构），一个是渲染树（控制节点如何渲染）。当渲染树构建完毕后，浏览器就可以根据渲染树来绘制页面了，在这个过程中页面就引发了一次页面重排和重绘，这是每个网页在加载时都会执行的。

过多的浏览器重绘和重排，需要付出高昂的性能代价从而大大减低页面的执行效率。

重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、background等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。

重排（或叫回流 flush）是DOM结构属性发生变化所触发的浏览器行为，例如改变元素的width,height,display 等属性，以及利用JS像页面中追加、删除和修改DOM节点。重排是更明显的一种改变，会导致整个渲染树的重新计算，也必然会有重绘，可见重排必然导致重绘。

###### 以下操作会产生重排/重绘

- 添加或删除可见的DOM 元素（重排&重绘）
- 元素位置改变（重排&重绘）
- 元素尺寸改变（重排&重绘）
- 内容改变，（重排&重绘）
- 浏览器窗口改变尺寸（重排&重绘）
- 字体大小改变（重排&重绘）
- 字体的颜色，Body的颜色改变（重绘）
- 同时当获取以下属性时，因为会造成浏览器强行刷新页面重排队列，而导致页面重排和重绘，这些属性和方法有 `offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`, `scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight`, `clientTop`, `clientLeft`, `clientWidth`, `clientHeight`, `getComputedStyle()` (`currentStyle()` in IE)

###### 减少浏览器的重排和重绘的方法

- 不要经常访问会引起浏览器flush队列的属性，需要的时候先缓存处理
- 将需要多次改变的元素的样式属性的，通过一次改变完成
  - 不要把DOM结点的属性值放在一个循环里当成循环里的变量
- 尽可能修改层级比较低的DOM
- 将新建的dom节点操作完毕后在插入到body中
- 把DOM离线后修改
  - 将页面中需要操作的节点先隐藏`display:none`，操作完毕后在显示
- 尽量减少持续改变和动态变化的效果。比如jquery的animate，尽量使用CSS3动画效果来实现
- 为动画的HTML元件使用fixed或absoult的position
- 不要使用 Table 布局
  - 因为可能很小的一个小改动会造成整个table的重新布局

检测工具

- [Google Chrome Timeline](http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/)

参考文章

- [浏览器的工作原理：新式网络浏览器幕后揭秘](http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- [现代浏览器的工作原理](http://feit.topming.com/how-modern-web-browsers-work/)
- [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)
- [页面重构应注意的repaint和reflow](http://www.aliued.cn/2012/11/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98repaints%E4%B8%8E%E9%87%8D%E6%8E%92reflows.html)


## CSS 基础知识

### CSS 选择器

##### 基础的选择器

- `*` 通用元素选择器 `* { margin: 0; padding: 0; }`
- `E` 标签选择器 `p { color: #333; }`
- `.` 类选择器 `.content { color: #333; }`
- `#` ID选择器 `#caption { color: #000; }`

##### 组合选择器

- `E,E` 多元素选择器 `a,p { color: #333; }`
- `E E` 后代元素选择器 `p a { color: #fff; }`
- `E > F` 子元素选择器 `p > a { color: #000; }`
- `E + F` 毗邻元素选择器 `p + p { color: #330; }`

##### 属性选择器

###### CSS 2.1

- `E[attr]` 匹配属性存在 `a[href] { color: #fff; }`
- `E[attr=val]` 匹配属性等于某值 `p[class="error"] { color: red; }`
- `E[attr~=val]` 匹配属性中含有某值，用空格分开 `p[class~="error"] { color: red; }`
- `E[attr|=val]` 匹配连字号分割，若为 `class` 只能匹配到只有一个 `class`且拥有 `-` 的元素 p[lang|=en] { color: green; }`


###### CSS 3

- `E[attr^="val"]` 属性attr的值以val开头的元素 `a[class^="btn-"] { color: red; }`
- `E[attr$="val"]` 属性attr的值以val结尾的元素 `a[class$="-red"] { color: red; }`
- `E[attr*="val"]` 属性attr的值包含val的元素 `a[class*="btn"] { color: red; }`

##### 伪类

###### CSS 2.1

- `E:first-child` 匹配父元素的第一个子元素 `p:first-child { color: #fff; }`
- `E:link` 匹配所未被点击的链接元素 `a:link { color: #fff; }`
- `E:visited` 匹配所有已被点击的链接元素 `a:visited { color: red; }`
- `E:active` 匹配鼠标已按下但未被释放的元素 `a:active { color: red; }`
- `E:hover` 匹配鼠标悬停的元素 `a:hover { color: red; }`
- `E:focus` 匹配获得当前焦点元素 `a:focus { color: red; }`
- [`E:in-range`](http://www.w3schools.com/cssref/sel_in-range.asp) 匹配 `type="number"` 并且在有效范围内的input元素 `input:in-range { color: red; }` IE 不支持
- [`E:out-of-range`](http://www.w3schools.com/cssref/sel_out-of-range.asp) 匹配 `type="number"` 并且不在有效范围内的input元素 `input:out-of-range { color: red; }` IE 不支持
- [`E:valid`](http://www.w3schools.com/cssref/sel_valid.asp) 匹配所有有效的input元素 `input:valid {}`
- [`E:invalid`](http://www.w3schools.com/cssref/sel_invalid.asp) 匹配所有无效的input元素 `input:invalid { color:red; }`
- [`E:optional`](http://www.w3schools.com/cssref/sel_optional.asp) 匹配所有没有 `required` 的input元素 `input:optional { color: red; }` IE 9以上才支持
- [`E:read-only`](http://www.w3schools.com/cssref/sel_read-only.asp) 匹配所有拥有 `readonly` 的input元素 `input:read-only {}`, `input:-moz-read-only {}`
- [`E:read-write`](http://www.w3schools.com/cssref/sel_read-write.asp) 匹配所有不拥有 `readonly` 的input元素 `input:read-write {}`，`input:-moz-read-write {}`
- [`E:lang(c)`](http://www.w3schools.com/cssref/sel_lang.asp) 匹配lang属性等于c的元素 `a:lang(sv) { quotes: “\201D” “\201D” “\2019″ “\2019″; }` 

###### CSS 3

表现性伪类

- `E:enabled` 匹配表单中激活的元素 `input:enabled { color: #000; }`
- `E:disabled` 匹配表单中禁用的元素 `input:disabled { color: #999; }`
- `E:checked` 匹配表单中被选中的单选框与复选框 `input[type="raido"]:checked { background-color: #fff; }`
- `E::selection` 匹配用户当前选中的元素 `p::selection { color: #555; }`

结构性伪类

- `:root` 匹配文档的根元素，对于HTML文档，就是HTML元素，权重大于 `html{}` `:root { color: #fff; }`
- `E:nth-child(n)` 匹配其父元素的第n个子元素，第一个编号为1， `p:nth-child(3) { color: #fff; }`，n由0开始 `p:nth-child(2n) {}`
- `E:nth-last-child(n)` 匹配其父元素的倒数第n个子元素，第一个编号为1 `p:nth-last-child(3) { color: #fff; }`
- `E:nth-of-type(n)` 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 `p:nth-of-type(3) { color: #fff; }`
- `E:nth-last-of-type(n)` 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 `p:nth-last-of-type(n) { color: #fff; }`
- `E:last-child` 匹配父元素的最后一个子元素，等同于:nth-last-child(1) `p:last-child { color: #fff; }`
- `E:first-of-type` 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) `p:first-of-type { color: #fff; }`
- `E:last-of-type` 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) `p:last-of-type { color: #fff; }`
- `E:only-child` 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)
- `E:only-of-type` 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)
- `E:empty` 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 `a:empty { display:block;width:100px;height:100px;background:#ff0; }`
- `E:not` 匹配不符合当前选择器的任何元素 `:not(p) { #fff; }`
- [`E:target`](http://www.w3schools.com/cssref/css3_pr_target.asp) 匹配文档中特定”id”点击后的效果，暂时主流浏览器都均不支持

##### 伪元素

- [`E::first-line`](https://developer.mozilla.org/en-US/docs/Web/CSS/::first-line) 匹配E元素的第一行 `p:first-line { color: red; }` 此时设置 `text-transform:uppercase;` 在 `webkit` 中无效。
- `E::first-letter` 匹配E元素的第一个字母 `p:first-letter { color: red; }`
- `E::before` 在E元素前插入生成的内容 `p:before { content: 'Hello'; }`
- `E::after` 在E元素后插入生成的内容 `p:after { content: 'World'; }`

##### 同级元素选择器

- `E ~ F` 匹配任何在E元素之后的同级F元素 `p ~ ul { color: red; }`



### 优先级与权重

一般我们描述CSS的优先级是这样：

!important > 内联 > id(#) > (class(.) > 同级元素通用选择器 > 标签|伪类|属性) > 伪元素 > 通配符 > 继承

其实括号内的选择器权重其实均相等，我们先探讨一下如何对比权重值与如何计算出权重的优先级。

#### 权重值的比较

而在普遍的文章描述中，经常会说到 ID 是100，Class 的权重是 10，标签是 1；
其实权重结算的结果并非如此，而是将这些更像如此 ID,Class,E，ID永远比Class优先
当出现这样的情况：

```
html body header nav ul li div p a span em { color: red; }
.num { color: yellow; }
```

此时样式色结果是 yellow，若按Class 权重为10来看，则明显应该是 red；所以我们可以确定此时权重应该是 0,0,11 0,1,0，
当 class 权重一样的时候，会根据次权重的即 E 权重的数值来比较，若都一样会通过后者来确定优先级；

##### 权重值的计算

一条样式规则的整体权重值包含四个独立的部分：[A, B, C, D]

- A表示内联选择器，只有1或者0两个值，若有我们标记A=1，否则A=0，标记的权重为 [1/0,0,0,0]
- B表示ID选择器，表示规则中的ID数量，标记的权重为 [0,N,0,0]
- C表示类选择器、属性选择器等，表示这些选择器的数量，标记的权重为 [0,0,N,0]
- D表示伪元素选择器及标签选择器，表示这些选择器的数量，标记的权重为 [0,0,0,N]

权重值只会看选择器的数量，而不会因为DOM树中两节点的距离而有所不同，例如：`html a == body a`。

##### `!important` 规则例外

当 !important 规则被应用在一个样式声明中时，该样式声明会覆盖CSS中任何其他的声明，无论它处在声明列表中的哪里。尽管如此，!important规则还是与优先级毫无关系。使用 !important 不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。

- Never 永远不要在全站范围的 css 上使用 !important
- Only 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用   !important
- Never 永远不要在你的插件中使用 !important
- Always 要优化考虑使用样式规则的优先级来解决问题而不是 !important

##### `:not` 伪类例外

:not 否定伪类在优先级计算中不会被看作是伪类。事实上，在计算选择器数量时还是会把其中的选择器当做普通选择器进行计数。

##### 关于 `inherit`

除了直接指定到元素上的样式规则以外，每个属性值还有一个可能为 inherit(继承) 的值。表示元素的该样式属性继承自父级元素，与父级元素的定义一致。
继承而来的属性值，权重永远低于明确指定到元素的定义。

参考文章

[优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)
[重新认识CSS的权重](http://www.cssforest.org/blog/index.php?id=185)

