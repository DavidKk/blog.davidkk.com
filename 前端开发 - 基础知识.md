<!-- title: 前端开发 - 基础知识 -->
<!-- author: <David Jones qowera@qq.com> -->
<!-- date: 2015-05-15 08:50:16 -->
<!-- category: 前端 -->
<!-- tag: 基础知识 -->

# [backup] 前端开发 - 基础知识

## TCP/IP, HTTP, Socket

网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。IP 协议对应于网络层；TCP 协议对应于传输层；TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输；而 HTTP 协议对应于应用层，主要解决如何包装数据，Socket 则是对 TCP/IP 协议的封装和应用。

### TCP - 传输控制协议

传输控制协议（Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。

TCP 连接包括三个状态：连接创建、数据传送和连接终止。操作系统将 TCP 连接抽象为套接字的编程接口给程序使用，并且要经历一系列的状态改变。

TCP用三路握手（three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。

- 客户端通过向服务器端发送一个 [SYN](http://baike.baidu.com/item/SYN) 来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。
- 服务器端应当为一个合法的 SYN 回送一个 SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
- 最后，客户端再发送一个 [ACK](http://baike.baidu.com/view/204040.htm)。当服务端受到这个 ACK 的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。

### HTTP - 超文本传送协议

HTTP 协议即超文本传送协议(Hypertext Transfer Protocol)，是 Web 联网的基础，HTTP 协议是建立在 TCP 协议之上的一种应用。

HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为"一次连接"。

- 在 HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
- 在 HTTP 1.1 中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

由于 HTTP 在每次请求结束后都会主动释放连接，因此 HTTP 连接是一种 "短连接"，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次 "保持连接" 的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端 "在线"。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

### Socket - 套接字

Socket 是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。

应用层通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP/IP 协议交互提供了 Socket 接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

### 建立 Socket 连接

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket。

套接字之间的连接过程分为三个步骤：
- 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
- 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
- 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

### Socket 连接与 TCP 连接

创建 Socket 连接时，可以指定使用的传输层协议，Socket 可以支持不同的传输层协议 (TCP or UDP)，当使用 TCP 协议进行连接时，该 Socket 连接就是一个 TCP 连接。

### Socket 连接与 HTTP 连接

由于通常情况下 Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是"请求—响应"的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 Socket 连接，服务器就可以直接将数据传送给客户端；若双方建立的是 HTTP 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在"询问"服务器是否有新的数据，如果有就将数据传给客户端。


参考资料
[传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)
[TCP/IP SOCKET HTTP及HTTPS之间的关系及各自特性之总结](http://kunyali.blog.51cto.com/4890065/1354922)


<!-- 浏览器篇 START -->

## 浏览器

### 浏览器内核

- Trident: IE
- Gecko: FF
- Servo (FF 与 Samsung 开发中):
- Presto: Opera (< v12.17)
- Webkit: Chrome, Safari, 360极速浏览器, 搜狗浏览器
- Blink (webkit的一个分支): Chrome (>= v28.0.1469.0), Opera

#### 为什么使用 Blink 非 Webkit

在多进程架构上，Google一开始就独自开发了一套沙盒多进程架构，它和后来由Apple主导的WebKit2多进程架构差异很大，为了支持WebKit2架构而加入WebCore的大量代码，对Google不但一点用也没有，还不得不花时间去处理兼容性的问题，而Google需要修改WebCore来支持自己架构的代码又很难进入WebKit主干，必须很小心处理避免影响其它的Port，大量的代码不得不通过迂回的方式放在外部处理，一些没方法在外部处理而需要对WebCore进行大改的特性不得不暂时放弃。
并且，因为历史原因，WebCore本身一开始就没有多线程或者多进程的概念，现有的架构对并行处理的支持非常困难，Google也认为必须对WebCore进行整体架构上的大改才能更好的支持并行处理，更充分利用多核CPU的能力，避免主线程过度拥挤（虽然现在大部分的WebKit Port都把主要的渲染工作分离到其它线程，但是主线程仍然需要负担HTML解析，CSS样式计算和匹配，排版，JS执行等繁重的任务，为了避免单项任务长时间阻塞主线程，WebCore目前是用延时Timer的方式将一个复杂任务分解成多段来顺序执行，这种方式即不优雅，更无法充分利用多核的能力）。
另外，WebCore现在的模块化比较混乱；一些历史遗留的代码和仅仅用于支持某些特定平台的代码导致WebCore代码臃肿不堪；平台相关的处理也没有一个统一的标准和方式，没有一个很好的抽象层去隔离平台相关和平台无关的部分；WebCore为了可以同时支持不同的JS虚拟机（如JSC和V8）导致了额外的性能开销和妨碍了对JS性能更多的改进；除此以外，更安全的隔离机制；对现有的网络层进行更大的结构优化等等这些原因也是Google需要自己发展Blink的主要原因。
总之，Chrome有太多激进的改进需要对WebCore进行大改，而原来那种在外围做文章，曲线救国的方式再也行不通，为了能够自行主导架构的演进方向，避免跟其它Port相互干扰，相互扯皮给双方带来的困扰和痛苦，加快开发的速度，从WebKit主干分离，自己发展新的浏览器引擎就成了必然的选择。

参考文章

- [各主流浏览器内核介绍](http://www.cnblogs.com/vajoy/p/3735553.html)
- [浏览器内核](http://baike.baidu.com/view/1369399.htm)
- [Why Blink and Why not Blink](http://blog.csdn.net/rogeryi/article/details/8759199)

### 浏览器工作原理

#### 浏览器结构

- 用户界面/User Interface - 包括浏览器主窗口、地址栏、前进/后退/停止/刷新等按钮、收藏夹等，其他显示的各个部分也都属于用户界面。
- 浏览器引擎/Browser Engine - 处于用户界面和渲染引擎之间，负责在两者之间传递操作。
- 渲染引擎/Rendering Engine - 负责显示请求的内容，比如HTML，就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
- 网络/Networking - 用于网络调用，比如 HTTP 请求。
- 用户界面后端/UI Backend - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- JavaScript 解释器。用于解析和执行 JavaScript 代码。
- 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

![浏览器的主要组件](http://feit.topming.com/wp-content/uploads/2014/08/Browser-components.png)

#### 渲染引擎主流程

###### 渲染引擎的基本流程

- 渲染引擎首先会通过网络层去获取请求的内容
- 获取到内容后，渲染引擎会进行这样流程：解析HTML构建DOM树 -> 渲染树的构建 -> 渲染树布局 -> 绘制渲染树 
- 不同的内核渲染流程可能不同

![渲染引擎的基本流程](http://feit.topming.com/wp-content/uploads/2014/08/flow.png)

- 解析HTML构建DOM树 `(DOM Tree)`
  - 解析HTML/SVG/XHTML文档来构建`DOM树 (DOM Tree)`，并将各个标签转化为内容树的DOM节点；
  - 解析外部和内部的CSS并数据来构建`CSS规则树 (CSS Rule Tree)`；
  - 解析Javascript，主要是通过`DOM API`和`CSSOM API`来操作`DOM Tree`和`CSS Rule Tree`；
- 渲染树的构建 `(Rendering Tree)`
  - 浏览器引擎会通过`DOM Tree`和`CSS Rule Tree`来构造`Rendering Tree`；
    - `Rendering Tree`渲染树并不等同于`DOM Tree`，因为一些像Header或display:none的东西就没必要放在渲染树中了；
    - `CSS Rule Tree`主要是为了完成匹配并把CSS Rule附加上`Rendering Tree`上的每个DOM节点。也就是所谓的Frame；
- 渲染树布局 `(Layout)`
  - 就可以根据各个Frame（也就是每个节点）计算分配在屏幕上的准确坐标；
- 绘制渲染树 `(Painting)`
  - 渲染引擎会遍历渲染树，通过用户界面后端API将节点绘制出来。

通常为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，为此在整个 HTML 文档解析完毕之前，就会开始构建渲染树和设置布局，在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。

###### Webkit 流程
![Webkit 流程](http://feit.topming.com/wp-content/uploads/2014/08/wekit-main-flow.png)

###### Mozilla Gecko 流程 
![Gecko 流程](http://feit.topming.com/wp-content/uploads/2014/08/gecko-main-flow.png)


### 重绘 (redraw) 和重排 (reflow)

一个页面载入成功以后形成两个内部数据结构，一个是DOM树（记录页面中的DOM节点结构），一个是渲染树（控制节点如何渲染）。当渲染树构建完毕后，浏览器就可以根据渲染树来绘制页面了，在这个过程中页面就引发了一次页面重排和重绘，这是每个网页在加载时都会执行的。

过多的浏览器重绘和重排，需要付出高昂的性能代价从而大大减低页面的执行效率。

重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、background等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。

重排（或叫回流 flush）是DOM结构属性发生变化所触发的浏览器行为，例如改变元素的width,height,display 等属性，以及利用JS像页面中追加、删除和修改DOM节点。重排是更明显的一种改变，会导致整个渲染树的重新计算，也必然会有重绘，可见重排必然导致重绘。

###### 以下操作会产生重排/重绘

- 添加或删除可见的DOM 元素（重排&重绘）
- 元素位置改变（重排&重绘）
- 元素尺寸改变（重排&重绘）
- 内容改变，（重排&重绘）
- 浏览器窗口改变尺寸（重排&重绘）
- 字体大小改变（重排&重绘）
- 字体的颜色，Body的颜色改变（重绘）
- 同时当获取以下属性时，因为会造成浏览器强行刷新页面重排队列，而导致页面重排和重绘，这些属性和方法有 `offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`, `scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight`, `clientTop`, `clientLeft`, `clientWidth`, `clientHeight`, `getComputedStyle()` (`currentStyle()` in IE)

###### 减少浏览器的重排和重绘的方法

- 不要经常访问会引起浏览器flush队列的属性，需要的时候先缓存处理
- 将需要多次改变的元素的样式属性的，通过一次改变完成
  - 不要把DOM结点的属性值放在一个循环里当成循环里的变量
- 尽可能修改层级比较低的DOM
- 将新建的dom节点操作完毕后在插入到body中
- 把DOM离线后修改
  - 将页面中需要操作的节点先隐藏`display:none`，操作完毕后在显示
- 尽量减少持续改变和动态变化的效果。比如jquery的animate，尽量使用CSS3动画效果来实现
- 为动画的HTML元件使用fixed或absoult的position
- 不要使用 Table 布局
  - 因为可能很小的一个小改动会造成整个table的重新布局

检测工具

- [Google Chrome Timeline](http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/)

参考文章

- [浏览器的工作原理：新式网络浏览器幕后揭秘](http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- [现代浏览器的工作原理](http://feit.topming.com/how-modern-web-browsers-work/)
- [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)
- [页面重构应注意的repaint和reflow](http://www.aliued.cn/2012/11/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98repaints%E4%B8%8E%E9%87%8D%E6%8E%92reflows.html)

<!-- 浏览器篇 END -->


<!-- CSS 篇 START -->

## CSS 基础知识

### 盒模型

盒模型有两种诠释，一种是IE盒模型，而另一种是W3C标准盒模型。

```
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃             margin             ┃
┃  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━┓  ┃
┃  ┃          border          ┃  ┃
┃  ┃  ┏━━━━━━━━━━━━━━━━━━━━┓  ┃  ┃
┃  ┃  ┃       padding      ┃  ┃  ┃
┃  ┃  ┃  ┏━━━━━━━━━━━━━━┓  ┃  ┃  ┃
┃  ┃  ┃  ┃              ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃    content   ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃              ┃  ┃  ┃  ┃
┃  ┃  ┃  ┗━━━━━━━━━━━━━━┛  ┃  ┃  ┃
┃  ┃  ┃                    ┃  ┃  ┃
┃  ┃  ┗━━━━━━━━━━━━━━━━━━━━┛  ┃  ┃
┃  ┃                          ┃  ┃
┃  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━┛  ┃
┃                                ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

#### 怪异模式 (Quirks mode) 与 标准模式 (Standards Mode)

IE 浏览器从服务端获取网页后会根据文档的 DOCTYPE 定义显示网页，如果文档正确定义了 DOCTYPE 浏览器则会进入标准模式（Standards Mode），否则浏览器会进入怪异模式或混杂模式（Quirks mode）
在标准模式下，浏览器会根据 W3C 的规范来渲染页面；而在怪异模式中，页面将以IE5的渲染方式来渲染页面。

IE盒模型：

- 主要有 IE5, IE6(Q), IE7(Q)
- width = content + padding left/right + border left/right
- box width = width + margin left/right

W3C盒模型：

- 主要由 IE6(S), IE7(S), W3C标准浏览器
- width = content 宽度
- box width = width + padding left/right + border left/right + margin left/right

因为IE盒模型更为合理，[事例](http://blog.csdn.net/ncode/article/details/7428746)，因此在 CSS3 中引入了 `box-sizing`，因此我们可以设置使用IE盒模型的渲染模式，IE8也支持。

```
* {
  box-sizing: border-box;
}
```

##### 设置标准模式

[最详细](http://www.fantxi.com/blog/archives/browser-mode/)

- 加 DOCTYPE 声明
- 设置 X-UA-Compatible 触发。

##### 设置怪异模式

- 无 doctype 声明、定义旧的HTML版本（HTML4以下, 例如3.2）
- 加XML声明，可在ie6下触发
- 在 XML 声明和 XHTML 的 DOCTYPE 之间加入 HTML 注释，可在ie7下触发
- `<!-- keep IE7 in quirks mode -->` 放在 `<!DOCTYPE` 前面


### CSS 选择器

##### 基础的选择器

- `*` 通用元素选择器 `* { margin: 0; padding: 0; }`
- `E` 标签选择器 `p { color: #333; }`
- `.` 类选择器 `.content { color: #333; }`
- `#` ID选择器 `#caption { color: #000; }`

##### 组合选择器

- `E,E` 多元素选择器 `a,p { color: #333; }`
- `E E` 后代元素选择器 `p a { color: #fff; }`
- `E > F` 子元素选择器 `p > a { color: #000; }`
- `E + F` 毗邻元素选择器 `p + p { color: #330; }`

##### 属性选择器

###### CSS 2.1

- `E[attr]` 匹配属性存在 `a[href] { color: #fff; }`
- `E[attr=val]` 匹配属性等于某值 `p[class="error"] { color: red; }`
- `E[attr~=val]` 匹配属性中含有某值，用空格分开 `p[class~="error"] { color: red; }`
- `E[attr|=val]` 匹配连字号分割，若为 `class` 只能匹配到只有一个 `class`且拥有 `-` 的元素 p[lang|=en] { color: green; }`


###### CSS 3

- `E[attr^="val"]` 属性attr的值以val开头的元素 `a[class^="btn-"] { color: red; }`
- `E[attr$="val"]` 属性attr的值以val结尾的元素 `a[class$="-red"] { color: red; }`
- `E[attr*="val"]` 属性attr的值包含val的元素 `a[class*="btn"] { color: red; }`

##### 伪类

###### CSS 2.1

- `E:first-child` 匹配父元素的第一个子元素 `p:first-child { color: #fff; }`
- `E:link` 匹配所未被点击的链接元素 `a:link { color: #fff; }`
- `E:visited` 匹配所有已被点击的链接元素 `a:visited { color: red; }`
- `E:active` 匹配鼠标已按下但未被释放的元素 `a:active { color: red; }`
- `E:hover` 匹配鼠标悬停的元素 `a:hover { color: red; }`
- `E:focus` 匹配获得当前焦点元素 `a:focus { color: red; }`
- [`E:in-range`](http://www.w3schools.com/cssref/sel_in-range.asp) 匹配 `type="number"` 并且在有效范围内的input元素 `input:in-range { color: red; }` IE 不支持
- [`E:out-of-range`](http://www.w3schools.com/cssref/sel_out-of-range.asp) 匹配 `type="number"` 并且不在有效范围内的input元素 `input:out-of-range { color: red; }` IE 不支持
- [`E:valid`](http://www.w3schools.com/cssref/sel_valid.asp) 匹配所有有效的input元素 `input:valid {}`
- [`E:invalid`](http://www.w3schools.com/cssref/sel_invalid.asp) 匹配所有无效的input元素 `input:invalid { color:red; }`
- [`E:optional`](http://www.w3schools.com/cssref/sel_optional.asp) 匹配所有没有 `required` 的input元素 `input:optional { color: red; }` IE 9以上才支持
- [`E:read-only`](http://www.w3schools.com/cssref/sel_read-only.asp) 匹配所有拥有 `readonly` 的input元素 `input:read-only {}`, `input:-moz-read-only {}`
- [`E:read-write`](http://www.w3schools.com/cssref/sel_read-write.asp) 匹配所有不拥有 `readonly` 的input元素 `input:read-write {}`，`input:-moz-read-write {}`
- [`E:lang(c)`](http://www.w3schools.com/cssref/sel_lang.asp) 匹配lang属性等于c的元素 `a:lang(sv) { quotes: “\201D” “\201D” “\2019″ “\2019″; }` 

###### CSS 3

表现性伪类

- `E:enabled` 匹配表单中激活的元素 `input:enabled { color: #000; }`
- `E:disabled` 匹配表单中禁用的元素 `input:disabled { color: #999; }`
- `E:checked` 匹配表单中被选中的单选框与复选框 `input[type="raido"]:checked { background-color: #fff; }`
- `E::selection` 匹配用户当前选中的元素 `p::selection { color: #555; }`

结构性伪类

- `:root` 匹配文档的根元素，对于HTML文档，就是HTML元素，权重大于 `html{}` `:root { color: #fff; }`
- `E:nth-child(n)` 匹配其父元素的第n个子元素，第一个编号为1， `p:nth-child(3) { color: #fff; }`，n由0开始 `p:nth-child(2n) {}`
- `E:nth-last-child(n)` 匹配其父元素的倒数第n个子元素，第一个编号为1 `p:nth-last-child(3) { color: #fff; }`
- `E:nth-of-type(n)` 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 `p:nth-of-type(3) { color: #fff; }`
- `E:nth-last-of-type(n)` 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 `p:nth-last-of-type(n) { color: #fff; }`
- `E:last-child` 匹配父元素的最后一个子元素，等同于:nth-last-child(1) `p:last-child { color: #fff; }`
- `E:first-of-type` 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) `p:first-of-type { color: #fff; }`
- `E:last-of-type` 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) `p:last-of-type { color: #fff; }`
- `E:only-child` 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)
- `E:only-of-type` 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)
- `E:empty` 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 `a:empty { display:block;width:100px;height:100px;background:#ff0; }`
- `E:not` 匹配不符合当前选择器的任何元素 `:not(p) { #fff; }`
- [`E:target`](http://www.w3schools.com/cssref/css3_pr_target.asp) 匹配文档中特定”id”点击后的效果，暂时主流浏览器都均不支持

##### 伪元素

- [`E::first-line`](https://developer.mozilla.org/en-US/docs/Web/CSS/::first-line) 匹配E元素的第一行 `p:first-line { color: red; }` 此时设置 `text-transform: uppercase;` 在 `webkit` 中无效。
- `E::first-letter` 匹配E元素的第一个字母 `p:first-letter { color: red; }`
- `E::before` 在E元素前插入生成的内容 `p:before { content: 'Hello'; }`
- `E::after` 在E元素后插入生成的内容 `p:after { content: 'World'; }`

##### 同级元素选择器

- `E ~ F` 匹配任何在E元素之后的同级F元素 `p ~ ul { color: red; }`

### 优先级与权重

一般我们描述CSS的优先级是这样：

!important > 内联 > id(#) > (class(.) > 同级元素通用选择器 > 伪类|属性) > 标签|伪元素 > 通配符 > 继承

其实括号内的选择器权重其实均相等，我们先探讨一下如何对比权重值与如何计算出权重的优先级。

#### 权重值的比较

而在普遍的文章描述中，经常会说到 ID 是100，Class 的权重是 10，标签是 1；
其实权重结算的结果并非如此，而是将这些更像如此 ID,Class,E，ID永远比Class优先
当出现这样的情况：

```
html body header nav ul li div p a span em { color: red; }
.num { color: yellow; }
```

此时样式色结果是 yellow，若按Class 权重为10来看，则明显应该是 red；所以我们可以确定此时权重应该是 0,0,11 0,1,0，
当 class 权重一样的时候，会根据次权重的即 E 权重的数值来比较，若都一样会通过后者来确定优先级；

##### 权重值的计算

一条样式规则的整体权重值包含四个独立的部分：[A, B, C, D]

- A表示内联选择器，只有1或者0两个值，若有我们标记A=1，否则A=0，标记的权重为 [1/0,0,0,0]
- B表示ID选择器，表示规则中的ID数量，标记的权重为 [0,N,0,0]
- C表示类选择器、属性选择器等，表示这些选择器的数量，标记的权重为 [0,0,N,0]
- D表示伪元素选择器及标签选择器，表示这些选择器的数量，标记的权重为 [0,0,0,N]

权重值只会看选择器的数量，而不会因为DOM树中两节点的距离而有所不同，例如：`html a == body a`。

##### `!important` 规则例外

当 !important 规则被应用在一个样式声明中时，该样式声明会覆盖CSS中任何其他的声明，无论它处在声明列表中的哪里。尽管如此，!important规则还是与优先级毫无关系。使用 !important 不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。

- Never 永远不要在全站范围的 css 上使用 !important
- Only 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用   !important
- Never 永远不要在你的插件中使用 !important
- Always 要优化考虑使用样式规则的优先级来解决问题而不是 !important

##### `:not` 伪类例外

:not 否定伪类在优先级计算中不会被看作是伪类。事实上，在计算选择器数量时还是会把其中的选择器当做普通选择器进行计数。

##### 关于 `inherit`

除了直接指定到元素上的样式规则以外，每个属性值还有一个可能为 inherit(继承) 的值。表示元素的该样式属性继承自父级元素，与父级元素的定义一致。
继承而来的属性值，权重永远低于明确指定到元素的定义。

参考文章

[优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)
[重新认识CSS的权重](http://www.cssforest.org/blog/index.php?id=185)

<!-- CSS 篇 END -->


<!-- Javascript 篇 START -->

## Javascript

### 作用域

作用域（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序
若出现同名变量，作用域中的变量会比全局变量的优先级高。而且改变作用域下的变量，全局变量不会受到任何影响。
Javascript 并没有块状作用域，因此在相同作用域下不同的块状中定义变量，他们均是该作用域变量，作用域下都能引用。

#### Scope Chain - 作用域链

作用域链就是包含了函數被創建的作用域中對象的集合。它決定了哪些數據能被函數訪問。
这个原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。

#### Hoisting - 声明提升

当定义一个变量时，定义的声明会在程序运行时优先执行定义(非赋值)

```
console.log(a)    // undefined，并不会
var a = 1         // 声明被提升，这里只执行赋值
console.log(a)    // 1
```

#### Window Scope

基于浏览器的 Javascript 定义一个全局变量可以通过给 Window 对象添加属性。
同时，没有经过 `var` 定义的变量均被定义为全局变量 (此情况是没有标志 `use strict` 的情况下)
当函数内部调用一个从未被定义的值，它会指向 Window，若通过 'use strict' 标志了该作用域，则会报错

#### 静态作用域 与 动态作用域

静态作用域 (Static/Lexical Scope) 又叫做词法作用域，采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见（visibility）；在这段区域以外该变量不可见（或无法访问）。词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。

动态作用域 (Dynamic Scope) 的变量叫做动态变量。只要程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。动态作用域里，取变量的值时，会由内向外逐层检查函数的调用链，并打印第一次遇到的那个绑定的值。

下面闭包章节将有具体例子详细说明

参考文章
[作用域](https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F#.E9.9D.99.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F.E4.B8.8E.E5.8A.A8.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F)


### Closure - 闭包

首先我们了解一下函数编程的一些基本定义，函数式语言中，函数即是数据，则我们可以把函数作为参数传递，也可以返回一个函数，然而在 ECMAScript 中也一样。
这些接受函数式参数的函数称为高阶函数 (HOF - high-order function)；
而带函数返回值的函数称为带函数值的函数 (functions with functional value)；
把自己作为参数的函数称为自应用函数 (self-applicative function)；
把自己作为返回值的函数称为自复制函数 (self-replicative function)

```
# 高阶函数
function q(funcVar) {
  funcVar()
}

# 带函数值的函数
function q() {
  return function() {}
}

# 自应用函数
(function() {
  
})()

# 自复制函数
function q() {
  return q
}
```

#### Funarg Problem - 泛函参数问题
Funarg Problem 的一个子问题是 upward funarg problem (自下而上)，当一个函数作为另一个函数的返回值时，并且使用了自由变量[free variable]的时候会发生。即便它的父级上下文环境已经结束了，它可以引用父级的变量。这个内部函数在创建时就会将父级的作用域链保存在自己的作用域[[Scope]]中。当函数运行时，上下文环境的作用域量是由活跃变量[activation object]和它[[Scope]]属性组合而成。

```
Scope chain = Activation object + [[Scope]]
```

请再次注意这个很重要的点 – 在函数创建期间[creation moment]，函数会将父级的作用域链保存起来，因为随后调用这个函数的时候使用的已经保存的作用域链来搜寻变量。

```
function foo() {
  var x = 10
  return function() {
    console.log(x)
  }
}

var x = 20
foo()()  // 10, but not 20
```

这种形式的作用域称为静态作用域。理论上来说，也会有动态作用域[dynamic scope], 也就是上述的x被解释为20，而不是10. 但是EMCAScript不使用动态作用域。

“funarg problem”的另一个类型就是自上而下[”downward funarg problem”].在这种情况下，父级的上下会存在，但是在判断一个变量值的时候会有多义性。也就是，这个变量究竟应该使用哪个作用域。是在函数创建时的作用域呢，还是在执行时的作用域呢？为了避免这种多义性，可以采用闭包，也就是使用静态作用域。

```
var x = 10

function foo() {
  console.log(x)
}

(function(funarg) {
  var x = 20
  
  // there is no ambiguity,
  // because we use global "x",
  // which was statically saved in
  // [[Scope]] of the "foo" function,
  // but not the "x" of the caller's scope,
  // which activates the "funArg"

  funarg() // 10, but not 20
})(foo)
```

从上述的情况，我们似乎可以断定，在语言中，使用静态作用域是闭包的一个强制性要求。不过，在某些语言中，会提供动态和静态作用域的结合，可以允许开发员选择哪一种作用域。但是在ECMAScript中，只采用了静态作用域。所以ECMAScript完全支持使用[[Scope]]的属性。我们可以给闭包得出如下定义

```
A closure is a combination of a code block (in ECMAScript this is a function) and statically/lexically saved all parent scopes.Thus, via these saved scopes a function may easily refer free variables.
```

闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。

几个函数可能含有相同的父级作用域（这是一个很普遍的情况，例如有好几个内部或者全局的函数）。在这种情况下，在[[Scope]]中存在的变量是会共享的。一个闭包中变量的变化，也会影响另一个闭包的。

#### 闭包的定义

闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数，也可以说闭包是由函数和与其相关的引用环境组合而成的实体。


参考文章
[深入理解JavaScript系列（16）：闭包（Closures）](http://www.cnblogs.com/tomxu/archive/2012/01/31/2330252.html)
[执行上下文其三：闭包 Closures](http://www.nowamagic.net/librarys/veda/detail/1646)


### 原型与继承

#### 原型模型

JavaScript 不包含传统的类继承模型，而是使用 prototypal 原型模型。在基于类的面向对象方式中，对象（object）依靠类（class）来产生。而在基于原型的面向对象方式中，对象（object）则是依靠构造器（constructor）利用 原型（prototype）构造出来的。在 JavaScript 中，"一切都是对象，函数是第一类"，`Function` 和 `Object` 都是函数的实例。

#### 生成对象方式

```
var obj = {
  name: 'david'
}

var Foo = function(name) {
  this.name = name
}

Foo.prototype.do = function() {}
var personA = new Foo('David')

# ECMAScript 5 引入, 相当于
Object.create = function(parent) {
  function Foo() {}
  Foo.prototype = parent;
  return new Foo();
}

var personB = Object.create({
  gender: 'male'
})

console.log(personB.gender) // male
```

#### prototype chain - 原型链

JavaScrip 可以采用构造器(constructor) 生成一个新的对象，每个构造器都拥有一个 prototype 属性，而每个通过此构造器生成的对象都有一个指向该构造器原型 (prototype) 的内部私有的链接 (proto)，而这个 prototype 因为是个对象，它也拥有自己的原型，这么一级一级指导原型为null，这就构成了原型链。

在 Javascript 中有一个隐藏的属性 `__proto__` (proto 是一个不应在你代码中出现的非正规的用法，这里仅仅用它来解释JavaScript原型继承的工作原理。)

```
var Foo = function() {}
Foo.prototype.say = 'hello'

var a = new Foo()
console.log(a.__proto__ === Foo.prototype) // true
console.log(a.__proto__.construct === Foo) // true
console.log(a.__proto__) // Foo { say: 'hello' } --> Foo.prototype
console.log(a.__proto__.__proto__) // Object {} --> Object.prototype
console.log(a.__proto__.__proto__) // null --> Object.__proto__
```

更复杂一点的原型链继承结构

```
function Animal(name) {
  this.name = name
}

Animal.prototype = {
  eat: function() {
    console.log('something to eat..')
  }
}

function Mammal() {
  this.name = 'mammal'
}

Mammal.prototype = new Animal('animal')
Mammal.prototype.constructor = Mammal

function Horse() {
  this.name = 'horse'
}

Horse.prototype = new Mammal()
Horse.prototype.constructor = Horse

Horse.prototype.eat = function() { 
  console.log('eat glass')
}

var horseA = new Horse()
console.log(horseA.__proto__ === Horse.prototype) // true
console.log(Horse.prototype.__proto__ === Mammal.prototype) // true
console.log(Mammal.prototype.__proto__ === Animal.prototype) // true
```

在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的隐式引用（implicit reference），这个引用称之为原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的原型链（prototype chain）

当前的原型继承（如 Object.create 以及 proto）还是存在以下缺点

- 标准性差：proto 不是一个标准用法，甚至是一个不赞成使用的用法。同时原生态的 Object.create 和道爷写的原版也不尽相同。
- 优化性差： 不论是原生的还是自定义的 Object.create ，其性能都远没有 new 的优化程度高，前者要比后者慢高达10倍。


##### 属性查找

当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined

##### hasOwnProperty

hasOwnProperty是Object.prototype的一个方法，它可是个好东西，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。

```
Object.prototype.bar = 1

var foo = {
  goo: undefined
}

cnosole.log(foo.bar) // 1
'bar' in foo // true

foo.hasOwnProperty('bar') // false
foo.hasOwnProperty('goo') // true
```


参考文章
[深入理解javascript原型继承](http://www.jianshu.com/p/d2742610ec30)
[深入理解JavaScript系列（5）：强大的原型和原型链](http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html)



<!-- Javascript 篇 END -->


<!-- HTML 篇 START -->

## HTML

### 标记语言 SGML, HTML, XML, XHTML

SGML  (Standard Generalized Markup Language，标准通用标记语言) 是现时常用的超文本格式的最高层次标准，是可以定义标记语言的元语言，甚至可以定义不必采用< >的常规方式。HTML 是被用 SGML 描述的标记语言
HTML  (HyperText Markup Language，超文本标记语言)，是为 "网页创建和其它可在网页浏览器中看到的信息" 设计的一种标记语言，适合 Web，可是标记较少，不支持其他领域的标记语言
XML   (eXtensible Markup Language，可扩展标记语言)，根据网上的理解，使用来在网络传输中表示数据的结构的，及我们可以通过 XML，可以得到数据的真实结构，与 HTML 对比理解，HTML 主要用于在网络上控制数据信息的布局，XML 则用于记录数据本身的结构，包括保存数据。前者侧重与表现，后者侧重于记录
XHTML (eXtensible HyperText Markup Language，可扩展超文本标记语言)，从继承关系上讲，HTML是一种基于标准通用标记语言（SGML）的应用，是一种非常灵活的置标语言，而XHTML则基于可扩展标记语言（XML），XML是SGML的一个子集

```
 ┏━━━━┓
 ┃SGML╋━━━┓
 ┗━╋━━┛   ┃ 
   ┃      ┃
 ┏━╋━┓  ┏━╋━━┓
 ┃XML┃  ┃HTML┃
 ┗━╋━┛  ┗━━━━┛
   ┃
   ┃
┏━━╋━━┓
┃XHTML┃
┗━━━━━┛
```

因此利用 SGML 创建了 HTML 参照和必须共同遵守的 DTD (document type definition，文本类型定义)，你会经常在 HTML 页面的头部发现 `DOCTYPE` 属性，用来定义用于解析目标 DTD

```
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

### SVG
SVG（Scalable Vector Graphics可缩放矢量图形）表示可缩放矢量图形。他是基于文本的图形语言，使用文本，线条，点等来进行图像绘制

<!-- HTML5 篇章 START -->

## HTML5

HTML5是最新的HTML标准，他的主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件，这些内容来自动画，视频，富GUI等；HTML5是万维网联盟（W3C）和网络超文本应用技术工作组（WHATWG）之间合作输出的。
HTML5没有使用SGML或者XHTML，他是一个全新的东西，因此你不需要参考DTD，对于HTML5，你仅需放置下面的文档类型代码告诉浏览器识别这是HTML5文档，若指明`<! DOCTYPE html>`，则浏览器不会认为该文档为HTML文档，会导致HTML5的标签不能正常工作。 

### HTML5 新增标签元素

#### 结构元素

- header - 页面头部
- nav - 主导航
- section - 独立章节
- article - 独立文章
- footer - 页面底部

#### 块级元素

- aside - 用于表示侧栏、贴士、摘要等
- figure - 用来包裹图片，并配合 `figcaption` 标签给图片一个说明
- [dialog](http://www.w3school.com.cn/tags/index.asp) - 用来表示人与人之间的交流互动，默认设置了绝对定位居中

#### 行内元素

- mark - 定义有记号的文本
- [time](http://www.w3school.com.cn/tags/tag_time.asp) - 时间格式，会在标签内给它一个datetime的属性，属性值为电脑可识别的时间格式 - `<time datetime="2008-02-14">情人节</time>`
- [meter](http://www.w3school.com.cn/tags/tag_meter.asp) - 标签定义度量衡，它拥有6个属性value, min, max, low, high, optimum，分别表示当前、最小、最大、低区、高区、最佳
- [progress](http://www.w3school.com.cn/tags/tag_progress.asp) - 用来表示进度条，value, max, 按照 value/max 来确定进度, IE9或以下不支持

#### 多媒体元素
- canvas - 定义图形
- [video](http://www.w3school.com.cn/tags/tag_video.asp) - HTML5 视频标签 - `<video src="movie.ogg" controls="controls"></video>`
- [audio](http://www.w3school.com.cn/tags/tag_audio.asp) - HTML 5 音频标签 - `<audio src="a.wav"></audio>`
- [source](http://www.w3school.com.cn/tags/tag_source.asp) - 定义媒介源，当媒体有多个的时候，浏览器会自动选择自身支持的那个媒介源
- [track](http://www.w3school.com.cn/tags/tag_track.asp) - 定义用在媒体播放器中的文本轨道，IE9,FF,Safari 不支持
- [embed](http://www.w3school.com.cn/tags/tag_embed.asp) - 定义嵌入的内容 - `<embed src="a.swf"/>`
- [details](http://www.w3school.com.cn/tags/tag_details.asp) - 用于描述文档或某个部分的细节，配合 `summary` 使用

#### 表单元素

- datalist - 定义下拉列表
- [keygen](http://www.w3school.com.cn/tags/tag_keygen.asp) - 标签规定用于表单的密钥对生成器字段，IE不支持
- [output](http://www.w3school.com.cn/tags/tag_output.asp) - 执行计算显示结果，IE 不支持
- datagrid - 可选数据的树形列表

#### 其他元素

- wbr - 定义一段 work brak 文本，不受任何样式影响
- menu - 菜单列表 (暂无支持)
- command - 行为按钮 (暂无支持)

#### 补充

- [datalist 不受任何样式影响](http://stackoverflow.com/questions/13693482/is-there-a-way-to-apply-a-css-style-on-html5-datalist-options)


### Web Worker

当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能
但是 Web worker 线程不能修改HTML元素，全局变量和Window.Location一类的窗口属性。你可以自由使用Javascript数据类型，XMLHttpRequest调用等

主页面，我们可以通过 `postMessage(sData)` 给内部发送消息，通过 `onmessage` `onerror` 等事件来捕获Worker内部返回的信息
Worker 没有加载好脚本之前，所有的 `postMessage()` 都会在 Worker 加载并执行完毕后被触发回调
当我们想停掉 Worker 时，我们可以使用 `terminate()`

Worker 线程，我们也是通过 `postMessage()` 来给外部发送消息
若想关闭 Worker 行为，我们则使用 `close()` 方法
`importScripts()` Worker 线程动态加载外部脚本，该方法会冻结 Worker 线程，直到动态加载脚本加载完毕或执行完毕(浏览器差异)
  - `importScripts()` 支持同时加载多个脚本
  - 同时加载多个脚本在各个浏览器中均为并行加载 (前提是HTTP连接数够用)
  - 但执行顺序是严格按照参数顺序进行的，无论哪个先加载完 (FF有差异) 

#### Web Worker 在各浏览器中的差异

##### 异常
Opera中，一旦发生一个语法错误或运行时错误，有时候会多抛出一个 Internal error 并且 lineno 总是 0
Opera中，一般的语法错误或执行期异常(如调用未定义变量，throw new Error(s)除外) 总是无法给出准确的错误信息且 lineno 总是 
Chrome、Safari中， `onerror` 并不捕获加载失败的404异常

##### 关于worker引入文件的缓存问题
Opera中，一但脚本被缓存起来那么即使右键-重新载入，也会直接去读 cache

##### 调用 `close()` 方法后的差异

Opera中，一但在 Worker 线程中调用 `close()` 方法，那么就代表着一切都结束了。如果在 `close()` 后你仍然试图使用 Worker 中的某些属性、事件、或方法则会抛出一个 Internal error，但其他浏览器则不会
Opera中，调用 `close()` 后，出现的 `postMessage()` 给主页面传递信息，不会再触发主页面的 `onmessage` 回调，其他浏览器则可以
FF中，调用 `close()` 后 Worker 虽然不再响应页面的 `postMessage()`，但是在 `close()` 调用之前，页面 `postMessage()` 给 Worker 线程的信息仍然会在 Worker 线程结束后被触发回调，其他浏览器则不会
chrome中，调用close()后 self 对象被赋值为 null 但你仍然可以和其他浏览器一样直接调用 WorkerGlobalScope 对象的方法。所以，应避免使用 self.postMessage，self.onmessage = function(){}，self.close() 而采用直接调用的方式 (如 onmessage=function(){}; )

##### 关于 `terminate()`

Opera 中，主页面调用 `terminate()` 后再调用 `postMessage()` 会抛出异常，其他浏览器则不会。
Opera 中，`terminate()` 执行之后，Worker 线程向外部传递数据或抛出异常均会被捕获，其他浏览器均不会。

##### 关于 `importScripts()`

FF中，`importScripts()` 加载脚本时，虽然同样会冻结当前 Worker 线程，但执行期是在 Worker 线程结束后，而其他浏览器的加载、执行都会冻结 Worker 线程。
FF中，`importScripts()` 方法加载多个脚本时，执行顺序是不确定的，遵循先到先执行原则
FF、Safari、Chrome 中，`importScripts()`加载脚本失败时，会抛出异常且可被主页面的 `onerror` 捕获，Opera 则不会
FF 中，`importScripts()` 加载多个脚本时，虽然都是并行加载，但执行却要等待文件都加载完毕后才开始执行，期间任何一个文件加载失败都将导致直接退出当前执行环境并且 Worker 线程代码也不回执行，其他浏览器则不会
Safari、Chrome，使用 `importScripts()` 加载多个脚本时，任何一个脚本加载失败，都将导致退出当前执行环境，但先加载好的外部脚本可以正常执行
Opera 会无视加载失败错误，继续执行后面的代码

##### 关于 Worker 内创建 Worker 的差异

Safari、chrome 不允许 Worker 内部再次创建一个 Worker，即 Safari、Chrome 中的 WorkerGlobal 并没有 Worker 成员
FF、opera 允许 Worker 内部再次创建一个 Worker

参考资料
[HTML5 Web Worker](http://www.cnblogs.com/_franky/archive/2010/11/23/1885773.html)

### Server-Sent Events (SSE) -  单向消息传递

Server-Sent 事件指的是网页自动获取来自服务器的更新。以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。

参考资料
[HTML 5 服务器发送事件](http://www.w3school.com.cn/html5/html_5_serversentevents.asp)

### Websocket

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行[全双工](https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5)通讯的协议，使服务端和客户端可以相互推送数据。在 WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。这里需要注意一点，这和 TCP 的三次握手又是不一样的。TCP 的三次握手是为了保证连接可靠，当 TCP 三次握手成功的时候，websocket 的握手阶段才真正开始。TCP 三次握手传送的是 TCP 报文，而websocket的握手传送的是 HTTP 报文，这个是不太一样的地方。

握手开始的时候，我们需要现发送一个HTTP 1.1的请求头部：

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

服务端返回的成功握手请求头部如下

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

一旦连接成功后，就可以在全双工的模式下在客户端和服务端之间来回传送WebSocket消息。这就意味着，在同一时间、任何方向，都可以双向发送基于文本的消息。每个消息已0×00字节开头，以0xff结尾（这样就可以解决TCP协议中的黏包问题，在TCP协议中，会存在两个缓冲区来存放发送的数据或者接收的数据，如果没有明显的分隔符，服务端无法正确识别命令），中间数据的编码是 UTF-8。

#### websocket 的使用



#### 使用 websocket 主要考虑因素

- 请求数：WebSocket可以一直保持连接，通过Socket通道传输数据，节省掉了建立连接需要耗费的时间。
- 服务器并发数：服务端要同时维持大量连接处于打开状态，就需要能以低性能开销接收高并发数据的架构。此类架构通常是围绕线程或所谓的非阻塞 IO 而设计的。这就与传统服务器围绕 HTTP 请求/响应循环的设计不同。这个时候，我们就会想到nodejs，使用事件机制和异步IO对请求进行处理，提高了服务器的并发能力，并且减少了线程切换带来的开销。


### Web Storage - Web 存储

#### LocalStorage (本地存储) 与 SessionStorage (会话存储)

LocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。
SessionStorage 与 LocalStorage 的接口类似，但保存数据的生命周期与 LocalStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 SessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，SessionStorage 中的数据就会被清空。

#### Web Storage 与 Cookie

Web Storage 的概念和 Cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
除此之外，Web Storage 拥有 setItem, getItem, removeItem, clear 等方法，不像 Cookie 需要前端开发者自己封装 setCookie，getCookie
Cookie 确实非常小，它的大小限制为4KB左右。Cookie 的作用是与服务器进行交互，作为HTTP规范的一部分而存在，而 Web Storage 仅仅是为了在本地存储数据而生
Cookie 可以设置失效时间；LocalStorage 除非被清除，否则永久保存；SessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除，在多个 Tab 浏览器中， Tab 关闭后重新打开，该会话也会存在
Cookie 的缺陷
- Cookie 的大小被限制在4KB
- Cookie 是随HTTP事务一起发送的，因此会浪费一部分发送 Cookie 时所使用的带宽
- Cookie 操作繁琐复杂


#### WebSQL



参考文章
[THE PAST, PRESENT & FUTURE OF LOCAL STORAGE FOR WEB APPLICATIONS](http://diveintohtml5.info/storage.html)
[what is the difference between localStorage, sessionStorage, session and cookie?](http://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookie)

<!-- HTML5 篇章 END -->
